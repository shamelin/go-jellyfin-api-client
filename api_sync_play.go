/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jellyfin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SyncPlayAPIService SyncPlayAPI service
type SyncPlayAPIService service

type SyncPlayAPISyncPlayBufferingRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinBufferRequestDto *JellyfinBufferRequestDto
}

// The player status.
func (r SyncPlayAPISyncPlayBufferingRequest) JellyfinBufferRequestDto(jellyfinBufferRequestDto JellyfinBufferRequestDto) SyncPlayAPISyncPlayBufferingRequest {
	r.jellyfinBufferRequestDto = &jellyfinBufferRequestDto
	return r
}

func (r SyncPlayAPISyncPlayBufferingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayBufferingExecute(r)
}

/*
SyncPlayBuffering Notify SyncPlay group that member is buffering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayBufferingRequest
*/
func (a *SyncPlayAPIService) SyncPlayBuffering(ctx context.Context) SyncPlayAPISyncPlayBufferingRequest {
	return SyncPlayAPISyncPlayBufferingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayBufferingExecute(r SyncPlayAPISyncPlayBufferingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayBuffering")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Buffering"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinBufferRequestDto == nil {
		return nil, reportError("jellyfinBufferRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinBufferRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayCreateGroupRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinNewGroupRequestDto *JellyfinNewGroupRequestDto
}

// The settings of the new group.
func (r SyncPlayAPISyncPlayCreateGroupRequest) JellyfinNewGroupRequestDto(jellyfinNewGroupRequestDto JellyfinNewGroupRequestDto) SyncPlayAPISyncPlayCreateGroupRequest {
	r.jellyfinNewGroupRequestDto = &jellyfinNewGroupRequestDto
	return r
}

func (r SyncPlayAPISyncPlayCreateGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayCreateGroupExecute(r)
}

/*
SyncPlayCreateGroup Create a new SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayCreateGroupRequest
*/
func (a *SyncPlayAPIService) SyncPlayCreateGroup(ctx context.Context) SyncPlayAPISyncPlayCreateGroupRequest {
	return SyncPlayAPISyncPlayCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayCreateGroupExecute(r SyncPlayAPISyncPlayCreateGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayCreateGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/New"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinNewGroupRequestDto == nil {
		return nil, reportError("jellyfinNewGroupRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinNewGroupRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayGetGroupsRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
}

func (r SyncPlayAPISyncPlayGetGroupsRequest) Execute() ([]JellyfinGroupInfoDto, *http.Response, error) {
	return r.ApiService.SyncPlayGetGroupsExecute(r)
}

/*
SyncPlayGetGroups Gets all SyncPlay groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayGetGroupsRequest
*/
func (a *SyncPlayAPIService) SyncPlayGetGroups(ctx context.Context) SyncPlayAPISyncPlayGetGroupsRequest {
	return SyncPlayAPISyncPlayGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinGroupInfoDto
func (a *SyncPlayAPIService) SyncPlayGetGroupsExecute(r SyncPlayAPISyncPlayGetGroupsRequest) ([]JellyfinGroupInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinGroupInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/List"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayJoinGroupRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinJoinGroupRequestDto *JellyfinJoinGroupRequestDto
}

// The group to join.
func (r SyncPlayAPISyncPlayJoinGroupRequest) JellyfinJoinGroupRequestDto(jellyfinJoinGroupRequestDto JellyfinJoinGroupRequestDto) SyncPlayAPISyncPlayJoinGroupRequest {
	r.jellyfinJoinGroupRequestDto = &jellyfinJoinGroupRequestDto
	return r
}

func (r SyncPlayAPISyncPlayJoinGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayJoinGroupExecute(r)
}

/*
SyncPlayJoinGroup Join an existing SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayJoinGroupRequest
*/
func (a *SyncPlayAPIService) SyncPlayJoinGroup(ctx context.Context) SyncPlayAPISyncPlayJoinGroupRequest {
	return SyncPlayAPISyncPlayJoinGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayJoinGroupExecute(r SyncPlayAPISyncPlayJoinGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayJoinGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Join"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinJoinGroupRequestDto == nil {
		return nil, reportError("jellyfinJoinGroupRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinJoinGroupRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayLeaveGroupRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
}

func (r SyncPlayAPISyncPlayLeaveGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayLeaveGroupExecute(r)
}

/*
SyncPlayLeaveGroup Leave the joined SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayLeaveGroupRequest
*/
func (a *SyncPlayAPIService) SyncPlayLeaveGroup(ctx context.Context) SyncPlayAPISyncPlayLeaveGroupRequest {
	return SyncPlayAPISyncPlayLeaveGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayLeaveGroupExecute(r SyncPlayAPISyncPlayLeaveGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayLeaveGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Leave"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayMovePlaylistItemRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinMovePlaylistItemRequestDto *JellyfinMovePlaylistItemRequestDto
}

// The new position for the item.
func (r SyncPlayAPISyncPlayMovePlaylistItemRequest) JellyfinMovePlaylistItemRequestDto(jellyfinMovePlaylistItemRequestDto JellyfinMovePlaylistItemRequestDto) SyncPlayAPISyncPlayMovePlaylistItemRequest {
	r.jellyfinMovePlaylistItemRequestDto = &jellyfinMovePlaylistItemRequestDto
	return r
}

func (r SyncPlayAPISyncPlayMovePlaylistItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayMovePlaylistItemExecute(r)
}

/*
SyncPlayMovePlaylistItem Request to move an item in the playlist in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayMovePlaylistItemRequest
*/
func (a *SyncPlayAPIService) SyncPlayMovePlaylistItem(ctx context.Context) SyncPlayAPISyncPlayMovePlaylistItemRequest {
	return SyncPlayAPISyncPlayMovePlaylistItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayMovePlaylistItemExecute(r SyncPlayAPISyncPlayMovePlaylistItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayMovePlaylistItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/MovePlaylistItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinMovePlaylistItemRequestDto == nil {
		return nil, reportError("jellyfinMovePlaylistItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinMovePlaylistItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayNextItemRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinNextItemRequestDto *JellyfinNextItemRequestDto
}

// The current item information.
func (r SyncPlayAPISyncPlayNextItemRequest) JellyfinNextItemRequestDto(jellyfinNextItemRequestDto JellyfinNextItemRequestDto) SyncPlayAPISyncPlayNextItemRequest {
	r.jellyfinNextItemRequestDto = &jellyfinNextItemRequestDto
	return r
}

func (r SyncPlayAPISyncPlayNextItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayNextItemExecute(r)
}

/*
SyncPlayNextItem Request next item in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayNextItemRequest
*/
func (a *SyncPlayAPIService) SyncPlayNextItem(ctx context.Context) SyncPlayAPISyncPlayNextItemRequest {
	return SyncPlayAPISyncPlayNextItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayNextItemExecute(r SyncPlayAPISyncPlayNextItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayNextItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/NextItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinNextItemRequestDto == nil {
		return nil, reportError("jellyfinNextItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinNextItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayPauseRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
}

func (r SyncPlayAPISyncPlayPauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayPauseExecute(r)
}

/*
SyncPlayPause Request pause in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayPauseRequest
*/
func (a *SyncPlayAPIService) SyncPlayPause(ctx context.Context) SyncPlayAPISyncPlayPauseRequest {
	return SyncPlayAPISyncPlayPauseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayPauseExecute(r SyncPlayAPISyncPlayPauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayPause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Pause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayPingRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinPingRequestDto *JellyfinPingRequestDto
}

// The new ping.
func (r SyncPlayAPISyncPlayPingRequest) JellyfinPingRequestDto(jellyfinPingRequestDto JellyfinPingRequestDto) SyncPlayAPISyncPlayPingRequest {
	r.jellyfinPingRequestDto = &jellyfinPingRequestDto
	return r
}

func (r SyncPlayAPISyncPlayPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayPingExecute(r)
}

/*
SyncPlayPing Update session ping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayPingRequest
*/
func (a *SyncPlayAPIService) SyncPlayPing(ctx context.Context) SyncPlayAPISyncPlayPingRequest {
	return SyncPlayAPISyncPlayPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayPingExecute(r SyncPlayAPISyncPlayPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayPing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinPingRequestDto == nil {
		return nil, reportError("jellyfinPingRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinPingRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayPreviousItemRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinPreviousItemRequestDto *JellyfinPreviousItemRequestDto
}

// The current item information.
func (r SyncPlayAPISyncPlayPreviousItemRequest) JellyfinPreviousItemRequestDto(jellyfinPreviousItemRequestDto JellyfinPreviousItemRequestDto) SyncPlayAPISyncPlayPreviousItemRequest {
	r.jellyfinPreviousItemRequestDto = &jellyfinPreviousItemRequestDto
	return r
}

func (r SyncPlayAPISyncPlayPreviousItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayPreviousItemExecute(r)
}

/*
SyncPlayPreviousItem Request previous item in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayPreviousItemRequest
*/
func (a *SyncPlayAPIService) SyncPlayPreviousItem(ctx context.Context) SyncPlayAPISyncPlayPreviousItemRequest {
	return SyncPlayAPISyncPlayPreviousItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayPreviousItemExecute(r SyncPlayAPISyncPlayPreviousItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayPreviousItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/PreviousItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinPreviousItemRequestDto == nil {
		return nil, reportError("jellyfinPreviousItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinPreviousItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayQueueRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinQueueRequestDto *JellyfinQueueRequestDto
}

// The items to add.
func (r SyncPlayAPISyncPlayQueueRequest) JellyfinQueueRequestDto(jellyfinQueueRequestDto JellyfinQueueRequestDto) SyncPlayAPISyncPlayQueueRequest {
	r.jellyfinQueueRequestDto = &jellyfinQueueRequestDto
	return r
}

func (r SyncPlayAPISyncPlayQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayQueueExecute(r)
}

/*
SyncPlayQueue Request to queue items to the playlist of a SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayQueueRequest
*/
func (a *SyncPlayAPIService) SyncPlayQueue(ctx context.Context) SyncPlayAPISyncPlayQueueRequest {
	return SyncPlayAPISyncPlayQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayQueueExecute(r SyncPlayAPISyncPlayQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinQueueRequestDto == nil {
		return nil, reportError("jellyfinQueueRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinQueueRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayReadyRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinReadyRequestDto *JellyfinReadyRequestDto
}

// The player status.
func (r SyncPlayAPISyncPlayReadyRequest) JellyfinReadyRequestDto(jellyfinReadyRequestDto JellyfinReadyRequestDto) SyncPlayAPISyncPlayReadyRequest {
	r.jellyfinReadyRequestDto = &jellyfinReadyRequestDto
	return r
}

func (r SyncPlayAPISyncPlayReadyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayReadyExecute(r)
}

/*
SyncPlayReady Notify SyncPlay group that member is ready for playback.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayReadyRequest
*/
func (a *SyncPlayAPIService) SyncPlayReady(ctx context.Context) SyncPlayAPISyncPlayReadyRequest {
	return SyncPlayAPISyncPlayReadyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayReadyExecute(r SyncPlayAPISyncPlayReadyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayReady")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinReadyRequestDto == nil {
		return nil, reportError("jellyfinReadyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinReadyRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayRemoveFromPlaylistRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinRemoveFromPlaylistRequestDto *JellyfinRemoveFromPlaylistRequestDto
}

// The items to remove.
func (r SyncPlayAPISyncPlayRemoveFromPlaylistRequest) JellyfinRemoveFromPlaylistRequestDto(jellyfinRemoveFromPlaylistRequestDto JellyfinRemoveFromPlaylistRequestDto) SyncPlayAPISyncPlayRemoveFromPlaylistRequest {
	r.jellyfinRemoveFromPlaylistRequestDto = &jellyfinRemoveFromPlaylistRequestDto
	return r
}

func (r SyncPlayAPISyncPlayRemoveFromPlaylistRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayRemoveFromPlaylistExecute(r)
}

/*
SyncPlayRemoveFromPlaylist Request to remove items from the playlist in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayRemoveFromPlaylistRequest
*/
func (a *SyncPlayAPIService) SyncPlayRemoveFromPlaylist(ctx context.Context) SyncPlayAPISyncPlayRemoveFromPlaylistRequest {
	return SyncPlayAPISyncPlayRemoveFromPlaylistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayRemoveFromPlaylistExecute(r SyncPlayAPISyncPlayRemoveFromPlaylistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayRemoveFromPlaylist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/RemoveFromPlaylist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinRemoveFromPlaylistRequestDto == nil {
		return nil, reportError("jellyfinRemoveFromPlaylistRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinRemoveFromPlaylistRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlaySeekRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinSeekRequestDto *JellyfinSeekRequestDto
}

// The new playback position.
func (r SyncPlayAPISyncPlaySeekRequest) JellyfinSeekRequestDto(jellyfinSeekRequestDto JellyfinSeekRequestDto) SyncPlayAPISyncPlaySeekRequest {
	r.jellyfinSeekRequestDto = &jellyfinSeekRequestDto
	return r
}

func (r SyncPlayAPISyncPlaySeekRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySeekExecute(r)
}

/*
SyncPlaySeek Request seek in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlaySeekRequest
*/
func (a *SyncPlayAPIService) SyncPlaySeek(ctx context.Context) SyncPlayAPISyncPlaySeekRequest {
	return SyncPlayAPISyncPlaySeekRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySeekExecute(r SyncPlayAPISyncPlaySeekRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySeek")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Seek"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinSeekRequestDto == nil {
		return nil, reportError("jellyfinSeekRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSeekRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlaySetIgnoreWaitRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinIgnoreWaitRequestDto *JellyfinIgnoreWaitRequestDto
}

// The settings to set.
func (r SyncPlayAPISyncPlaySetIgnoreWaitRequest) JellyfinIgnoreWaitRequestDto(jellyfinIgnoreWaitRequestDto JellyfinIgnoreWaitRequestDto) SyncPlayAPISyncPlaySetIgnoreWaitRequest {
	r.jellyfinIgnoreWaitRequestDto = &jellyfinIgnoreWaitRequestDto
	return r
}

func (r SyncPlayAPISyncPlaySetIgnoreWaitRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetIgnoreWaitExecute(r)
}

/*
SyncPlaySetIgnoreWait Request SyncPlay group to ignore member during group-wait.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlaySetIgnoreWaitRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetIgnoreWait(ctx context.Context) SyncPlayAPISyncPlaySetIgnoreWaitRequest {
	return SyncPlayAPISyncPlaySetIgnoreWaitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetIgnoreWaitExecute(r SyncPlayAPISyncPlaySetIgnoreWaitRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetIgnoreWait")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetIgnoreWait"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinIgnoreWaitRequestDto == nil {
		return nil, reportError("jellyfinIgnoreWaitRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinIgnoreWaitRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlaySetNewQueueRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinPlayRequestDto *JellyfinPlayRequestDto
}

// The new playlist to play in the group.
func (r SyncPlayAPISyncPlaySetNewQueueRequest) JellyfinPlayRequestDto(jellyfinPlayRequestDto JellyfinPlayRequestDto) SyncPlayAPISyncPlaySetNewQueueRequest {
	r.jellyfinPlayRequestDto = &jellyfinPlayRequestDto
	return r
}

func (r SyncPlayAPISyncPlaySetNewQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetNewQueueExecute(r)
}

/*
SyncPlaySetNewQueue Request to set new playlist in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlaySetNewQueueRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetNewQueue(ctx context.Context) SyncPlayAPISyncPlaySetNewQueueRequest {
	return SyncPlayAPISyncPlaySetNewQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetNewQueueExecute(r SyncPlayAPISyncPlaySetNewQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetNewQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetNewQueue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinPlayRequestDto == nil {
		return nil, reportError("jellyfinPlayRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinPlayRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlaySetPlaylistItemRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinSetPlaylistItemRequestDto *JellyfinSetPlaylistItemRequestDto
}

// The new item to play.
func (r SyncPlayAPISyncPlaySetPlaylistItemRequest) JellyfinSetPlaylistItemRequestDto(jellyfinSetPlaylistItemRequestDto JellyfinSetPlaylistItemRequestDto) SyncPlayAPISyncPlaySetPlaylistItemRequest {
	r.jellyfinSetPlaylistItemRequestDto = &jellyfinSetPlaylistItemRequestDto
	return r
}

func (r SyncPlayAPISyncPlaySetPlaylistItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetPlaylistItemExecute(r)
}

/*
SyncPlaySetPlaylistItem Request to change playlist item in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlaySetPlaylistItemRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetPlaylistItem(ctx context.Context) SyncPlayAPISyncPlaySetPlaylistItemRequest {
	return SyncPlayAPISyncPlaySetPlaylistItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetPlaylistItemExecute(r SyncPlayAPISyncPlaySetPlaylistItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetPlaylistItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetPlaylistItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinSetPlaylistItemRequestDto == nil {
		return nil, reportError("jellyfinSetPlaylistItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSetPlaylistItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlaySetRepeatModeRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinSetRepeatModeRequestDto *JellyfinSetRepeatModeRequestDto
}

// The new repeat mode.
func (r SyncPlayAPISyncPlaySetRepeatModeRequest) JellyfinSetRepeatModeRequestDto(jellyfinSetRepeatModeRequestDto JellyfinSetRepeatModeRequestDto) SyncPlayAPISyncPlaySetRepeatModeRequest {
	r.jellyfinSetRepeatModeRequestDto = &jellyfinSetRepeatModeRequestDto
	return r
}

func (r SyncPlayAPISyncPlaySetRepeatModeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetRepeatModeExecute(r)
}

/*
SyncPlaySetRepeatMode Request to set repeat mode in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlaySetRepeatModeRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetRepeatMode(ctx context.Context) SyncPlayAPISyncPlaySetRepeatModeRequest {
	return SyncPlayAPISyncPlaySetRepeatModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetRepeatModeExecute(r SyncPlayAPISyncPlaySetRepeatModeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetRepeatMode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetRepeatMode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinSetRepeatModeRequestDto == nil {
		return nil, reportError("jellyfinSetRepeatModeRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSetRepeatModeRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlaySetShuffleModeRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
	jellyfinSetShuffleModeRequestDto *JellyfinSetShuffleModeRequestDto
}

// The new shuffle mode.
func (r SyncPlayAPISyncPlaySetShuffleModeRequest) JellyfinSetShuffleModeRequestDto(jellyfinSetShuffleModeRequestDto JellyfinSetShuffleModeRequestDto) SyncPlayAPISyncPlaySetShuffleModeRequest {
	r.jellyfinSetShuffleModeRequestDto = &jellyfinSetShuffleModeRequestDto
	return r
}

func (r SyncPlayAPISyncPlaySetShuffleModeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetShuffleModeExecute(r)
}

/*
SyncPlaySetShuffleMode Request to set shuffle mode in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlaySetShuffleModeRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetShuffleMode(ctx context.Context) SyncPlayAPISyncPlaySetShuffleModeRequest {
	return SyncPlayAPISyncPlaySetShuffleModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetShuffleModeExecute(r SyncPlayAPISyncPlaySetShuffleModeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetShuffleMode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetShuffleMode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinSetShuffleModeRequestDto == nil {
		return nil, reportError("jellyfinSetShuffleModeRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSetShuffleModeRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayStopRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
}

func (r SyncPlayAPISyncPlayStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayStopExecute(r)
}

/*
SyncPlayStop Request stop in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayStopRequest
*/
func (a *SyncPlayAPIService) SyncPlayStop(ctx context.Context) SyncPlayAPISyncPlayStopRequest {
	return SyncPlayAPISyncPlayStopRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayStopExecute(r SyncPlayAPISyncPlayStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SyncPlayAPISyncPlayUnpauseRequest struct {
	ctx context.Context
	ApiService *SyncPlayAPIService
}

func (r SyncPlayAPISyncPlayUnpauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayUnpauseExecute(r)
}

/*
SyncPlayUnpause Request unpause in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SyncPlayAPISyncPlayUnpauseRequest
*/
func (a *SyncPlayAPIService) SyncPlayUnpause(ctx context.Context) SyncPlayAPISyncPlayUnpauseRequest {
	return SyncPlayAPISyncPlayUnpauseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayUnpauseExecute(r SyncPlayAPISyncPlayUnpauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayUnpause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Unpause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

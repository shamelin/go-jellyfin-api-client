/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jellyfin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
	"time"
)


// LiveTvAPIService LiveTvAPI service
type LiveTvAPIService service

type LiveTvAPIAddListingProviderRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	pw *string
	validateListings *bool
	validateLogin *bool
	jellyfinListingsProviderInfo *JellyfinListingsProviderInfo
}

// Password.
func (r LiveTvAPIAddListingProviderRequest) Pw(pw string) LiveTvAPIAddListingProviderRequest {
	r.pw = &pw
	return r
}

// Validate listings.
func (r LiveTvAPIAddListingProviderRequest) ValidateListings(validateListings bool) LiveTvAPIAddListingProviderRequest {
	r.validateListings = &validateListings
	return r
}

// Validate login.
func (r LiveTvAPIAddListingProviderRequest) ValidateLogin(validateLogin bool) LiveTvAPIAddListingProviderRequest {
	r.validateLogin = &validateLogin
	return r
}

// New listings info.
func (r LiveTvAPIAddListingProviderRequest) JellyfinListingsProviderInfo(jellyfinListingsProviderInfo JellyfinListingsProviderInfo) LiveTvAPIAddListingProviderRequest {
	r.jellyfinListingsProviderInfo = &jellyfinListingsProviderInfo
	return r
}

func (r LiveTvAPIAddListingProviderRequest) Execute() (*JellyfinListingsProviderInfo, *http.Response, error) {
	return r.ApiService.AddListingProviderExecute(r)
}

/*
AddListingProvider Adds a listings provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIAddListingProviderRequest
*/
func (a *LiveTvAPIService) AddListingProvider(ctx context.Context) LiveTvAPIAddListingProviderRequest {
	return LiveTvAPIAddListingProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinListingsProviderInfo
func (a *LiveTvAPIService) AddListingProviderExecute(r LiveTvAPIAddListingProviderRequest) (*JellyfinListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.AddListingProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pw", r.pw, "form", "")
	}
	if r.validateListings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateListings", r.validateListings, "form", "")
	} else {
		var defaultValue bool = false
		r.validateListings = &defaultValue
	}
	if r.validateLogin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateLogin", r.validateLogin, "form", "")
	} else {
		var defaultValue bool = false
		r.validateLogin = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinListingsProviderInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIAddTunerHostRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	jellyfinTunerHostInfo *JellyfinTunerHostInfo
}

// New tuner host.
func (r LiveTvAPIAddTunerHostRequest) JellyfinTunerHostInfo(jellyfinTunerHostInfo JellyfinTunerHostInfo) LiveTvAPIAddTunerHostRequest {
	r.jellyfinTunerHostInfo = &jellyfinTunerHostInfo
	return r
}

func (r LiveTvAPIAddTunerHostRequest) Execute() (*JellyfinTunerHostInfo, *http.Response, error) {
	return r.ApiService.AddTunerHostExecute(r)
}

/*
AddTunerHost Adds a tuner host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIAddTunerHostRequest
*/
func (a *LiveTvAPIService) AddTunerHost(ctx context.Context) LiveTvAPIAddTunerHostRequest {
	return LiveTvAPIAddTunerHostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinTunerHostInfo
func (a *LiveTvAPIService) AddTunerHostExecute(r LiveTvAPIAddTunerHostRequest) (*JellyfinTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.AddTunerHost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinTunerHostInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPICancelSeriesTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	timerId string
}

func (r LiveTvAPICancelSeriesTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelSeriesTimerExecute(r)
}

/*
CancelSeriesTimer Cancels a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return LiveTvAPICancelSeriesTimerRequest
*/
func (a *LiveTvAPIService) CancelSeriesTimer(ctx context.Context, timerId string) LiveTvAPICancelSeriesTimerRequest {
	return LiveTvAPICancelSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CancelSeriesTimerExecute(r LiveTvAPICancelSeriesTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CancelSeriesTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPICancelTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	timerId string
}

func (r LiveTvAPICancelTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelTimerExecute(r)
}

/*
CancelTimer Cancels a live tv timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return LiveTvAPICancelTimerRequest
*/
func (a *LiveTvAPIService) CancelTimer(ctx context.Context, timerId string) LiveTvAPICancelTimerRequest {
	return LiveTvAPICancelTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CancelTimerExecute(r LiveTvAPICancelTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CancelTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPICreateSeriesTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	jellyfinSeriesTimerInfoDto *JellyfinSeriesTimerInfoDto
}

// New series timer info.
func (r LiveTvAPICreateSeriesTimerRequest) JellyfinSeriesTimerInfoDto(jellyfinSeriesTimerInfoDto JellyfinSeriesTimerInfoDto) LiveTvAPICreateSeriesTimerRequest {
	r.jellyfinSeriesTimerInfoDto = &jellyfinSeriesTimerInfoDto
	return r
}

func (r LiveTvAPICreateSeriesTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSeriesTimerExecute(r)
}

/*
CreateSeriesTimer Creates a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPICreateSeriesTimerRequest
*/
func (a *LiveTvAPIService) CreateSeriesTimer(ctx context.Context) LiveTvAPICreateSeriesTimerRequest {
	return LiveTvAPICreateSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CreateSeriesTimerExecute(r LiveTvAPICreateSeriesTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CreateSeriesTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSeriesTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPICreateTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	jellyfinTimerInfoDto *JellyfinTimerInfoDto
}

// New timer info.
func (r LiveTvAPICreateTimerRequest) JellyfinTimerInfoDto(jellyfinTimerInfoDto JellyfinTimerInfoDto) LiveTvAPICreateTimerRequest {
	r.jellyfinTimerInfoDto = &jellyfinTimerInfoDto
	return r
}

func (r LiveTvAPICreateTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTimerExecute(r)
}

/*
CreateTimer Creates a live tv timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPICreateTimerRequest
*/
func (a *LiveTvAPIService) CreateTimer(ctx context.Context) LiveTvAPICreateTimerRequest {
	return LiveTvAPICreateTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CreateTimerExecute(r LiveTvAPICreateTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CreateTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPIDeleteListingProviderRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	id *string
}

// Listing provider id.
func (r LiveTvAPIDeleteListingProviderRequest) Id(id string) LiveTvAPIDeleteListingProviderRequest {
	r.id = &id
	return r
}

func (r LiveTvAPIDeleteListingProviderRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListingProviderExecute(r)
}

/*
DeleteListingProvider Delete listing provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIDeleteListingProviderRequest
*/
func (a *LiveTvAPIService) DeleteListingProvider(ctx context.Context) LiveTvAPIDeleteListingProviderRequest {
	return LiveTvAPIDeleteListingProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) DeleteListingProviderExecute(r LiveTvAPIDeleteListingProviderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DeleteListingProvider")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPIDeleteRecordingRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	recordingId string
}

func (r LiveTvAPIDeleteRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingExecute(r)
}

/*
DeleteRecording Deletes a live tv recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordingId Recording id.
 @return LiveTvAPIDeleteRecordingRequest
*/
func (a *LiveTvAPIService) DeleteRecording(ctx context.Context, recordingId string) LiveTvAPIDeleteRecordingRequest {
	return LiveTvAPIDeleteRecordingRequest{
		ApiService: a,
		ctx: ctx,
		recordingId: recordingId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) DeleteRecordingExecute(r LiveTvAPIDeleteRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DeleteRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{recordingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"recordingId"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPIDeleteTunerHostRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	id *string
}

// Tuner host id.
func (r LiveTvAPIDeleteTunerHostRequest) Id(id string) LiveTvAPIDeleteTunerHostRequest {
	r.id = &id
	return r
}

func (r LiveTvAPIDeleteTunerHostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTunerHostExecute(r)
}

/*
DeleteTunerHost Deletes a tuner host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIDeleteTunerHostRequest
*/
func (a *LiveTvAPIService) DeleteTunerHost(ctx context.Context) LiveTvAPIDeleteTunerHostRequest {
	return LiveTvAPIDeleteTunerHostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) DeleteTunerHostExecute(r LiveTvAPIDeleteTunerHostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DeleteTunerHost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPIDiscoverTunersRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	newDevicesOnly *bool
}

// Only discover new tuners.
func (r LiveTvAPIDiscoverTunersRequest) NewDevicesOnly(newDevicesOnly bool) LiveTvAPIDiscoverTunersRequest {
	r.newDevicesOnly = &newDevicesOnly
	return r
}

func (r LiveTvAPIDiscoverTunersRequest) Execute() ([]JellyfinTunerHostInfo, *http.Response, error) {
	return r.ApiService.DiscoverTunersExecute(r)
}

/*
DiscoverTuners Discover tuners.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIDiscoverTunersRequest
*/
func (a *LiveTvAPIService) DiscoverTuners(ctx context.Context) LiveTvAPIDiscoverTunersRequest {
	return LiveTvAPIDiscoverTunersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinTunerHostInfo
func (a *LiveTvAPIService) DiscoverTunersExecute(r LiveTvAPIDiscoverTunersRequest) ([]JellyfinTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DiscoverTuners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/Discover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.newDevicesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newDevicesOnly", r.newDevicesOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.newDevicesOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIDiscvoverTunersRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	newDevicesOnly *bool
}

// Only discover new tuners.
func (r LiveTvAPIDiscvoverTunersRequest) NewDevicesOnly(newDevicesOnly bool) LiveTvAPIDiscvoverTunersRequest {
	r.newDevicesOnly = &newDevicesOnly
	return r
}

func (r LiveTvAPIDiscvoverTunersRequest) Execute() ([]JellyfinTunerHostInfo, *http.Response, error) {
	return r.ApiService.DiscvoverTunersExecute(r)
}

/*
DiscvoverTuners Discover tuners.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIDiscvoverTunersRequest
*/
func (a *LiveTvAPIService) DiscvoverTuners(ctx context.Context) LiveTvAPIDiscvoverTunersRequest {
	return LiveTvAPIDiscvoverTunersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinTunerHostInfo
func (a *LiveTvAPIService) DiscvoverTunersExecute(r LiveTvAPIDiscvoverTunersRequest) ([]JellyfinTunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinTunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DiscvoverTuners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/Discvover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.newDevicesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newDevicesOnly", r.newDevicesOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.newDevicesOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetChannelRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	channelId string
	userId *string
}

// Optional. Attach user data.
func (r LiveTvAPIGetChannelRequest) UserId(userId string) LiveTvAPIGetChannelRequest {
	r.userId = &userId
	return r
}

func (r LiveTvAPIGetChannelRequest) Execute() (*JellyfinBaseItemDto, *http.Response, error) {
	return r.ApiService.GetChannelExecute(r)
}

/*
GetChannel Gets a live tv channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel id.
 @return LiveTvAPIGetChannelRequest
*/
func (a *LiveTvAPIService) GetChannel(ctx context.Context, channelId string) LiveTvAPIGetChannelRequest {
	return LiveTvAPIGetChannelRequest{
		ApiService: a,
		ctx: ctx,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDto
func (a *LiveTvAPIService) GetChannelExecute(r LiveTvAPIGetChannelRequest) (*JellyfinBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetChannelMappingOptionsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	providerId *string
}

// Provider id.
func (r LiveTvAPIGetChannelMappingOptionsRequest) ProviderId(providerId string) LiveTvAPIGetChannelMappingOptionsRequest {
	r.providerId = &providerId
	return r
}

func (r LiveTvAPIGetChannelMappingOptionsRequest) Execute() (*JellyfinChannelMappingOptionsDto, *http.Response, error) {
	return r.ApiService.GetChannelMappingOptionsExecute(r)
}

/*
GetChannelMappingOptions Get channel mapping options.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetChannelMappingOptionsRequest
*/
func (a *LiveTvAPIService) GetChannelMappingOptions(ctx context.Context) LiveTvAPIGetChannelMappingOptionsRequest {
	return LiveTvAPIGetChannelMappingOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinChannelMappingOptionsDto
func (a *LiveTvAPIService) GetChannelMappingOptionsExecute(r LiveTvAPIGetChannelMappingOptionsRequest) (*JellyfinChannelMappingOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinChannelMappingOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetChannelMappingOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.providerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerId", r.providerId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetDefaultListingProviderRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
}

func (r LiveTvAPIGetDefaultListingProviderRequest) Execute() (*JellyfinListingsProviderInfo, *http.Response, error) {
	return r.ApiService.GetDefaultListingProviderExecute(r)
}

/*
GetDefaultListingProvider Gets default listings provider info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetDefaultListingProviderRequest
*/
func (a *LiveTvAPIService) GetDefaultListingProvider(ctx context.Context) LiveTvAPIGetDefaultListingProviderRequest {
	return LiveTvAPIGetDefaultListingProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinListingsProviderInfo
func (a *LiveTvAPIService) GetDefaultListingProviderExecute(r LiveTvAPIGetDefaultListingProviderRequest) (*JellyfinListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetDefaultListingProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetDefaultTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	programId *string
}

// Optional. To attach default values based on a program.
func (r LiveTvAPIGetDefaultTimerRequest) ProgramId(programId string) LiveTvAPIGetDefaultTimerRequest {
	r.programId = &programId
	return r
}

func (r LiveTvAPIGetDefaultTimerRequest) Execute() (*JellyfinSeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetDefaultTimerExecute(r)
}

/*
GetDefaultTimer Gets the default values for a new timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetDefaultTimerRequest
*/
func (a *LiveTvAPIService) GetDefaultTimer(ctx context.Context) LiveTvAPIGetDefaultTimerRequest {
	return LiveTvAPIGetDefaultTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinSeriesTimerInfoDto
func (a *LiveTvAPIService) GetDefaultTimerExecute(r LiveTvAPIGetDefaultTimerRequest) (*JellyfinSeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinSeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetDefaultTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/Defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.programId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programId", r.programId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetGuideInfoRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
}

func (r LiveTvAPIGetGuideInfoRequest) Execute() (*JellyfinGuideInfo, *http.Response, error) {
	return r.ApiService.GetGuideInfoExecute(r)
}

/*
GetGuideInfo Get guid info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetGuideInfoRequest
*/
func (a *LiveTvAPIService) GetGuideInfo(ctx context.Context) LiveTvAPIGetGuideInfoRequest {
	return LiveTvAPIGetGuideInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinGuideInfo
func (a *LiveTvAPIService) GetGuideInfoExecute(r LiveTvAPIGetGuideInfoRequest) (*JellyfinGuideInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinGuideInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetGuideInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/GuideInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetLineupsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	id *string
	type_ *string
	location *string
	country *string
}

// Provider id.
func (r LiveTvAPIGetLineupsRequest) Id(id string) LiveTvAPIGetLineupsRequest {
	r.id = &id
	return r
}

// Provider type.
func (r LiveTvAPIGetLineupsRequest) Type_(type_ string) LiveTvAPIGetLineupsRequest {
	r.type_ = &type_
	return r
}

// Location.
func (r LiveTvAPIGetLineupsRequest) Location(location string) LiveTvAPIGetLineupsRequest {
	r.location = &location
	return r
}

// Country.
func (r LiveTvAPIGetLineupsRequest) Country(country string) LiveTvAPIGetLineupsRequest {
	r.country = &country
	return r
}

func (r LiveTvAPIGetLineupsRequest) Execute() ([]JellyfinNameIdPair, *http.Response, error) {
	return r.ApiService.GetLineupsExecute(r)
}

/*
GetLineups Gets available lineups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetLineupsRequest
*/
func (a *LiveTvAPIService) GetLineups(ctx context.Context) LiveTvAPIGetLineupsRequest {
	return LiveTvAPIGetLineupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinNameIdPair
func (a *LiveTvAPIService) GetLineupsExecute(r LiveTvAPIGetLineupsRequest) ([]JellyfinNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLineups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Lineups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetLiveRecordingFileRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	recordingId string
}

func (r LiveTvAPIGetLiveRecordingFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLiveRecordingFileExecute(r)
}

/*
GetLiveRecordingFile Gets a live tv recording stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordingId Recording id.
 @return LiveTvAPIGetLiveRecordingFileRequest
*/
func (a *LiveTvAPIService) GetLiveRecordingFile(ctx context.Context, recordingId string) LiveTvAPIGetLiveRecordingFileRequest {
	return LiveTvAPIGetLiveRecordingFileRequest{
		ApiService: a,
		ctx: ctx,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *LiveTvAPIService) GetLiveRecordingFileExecute(r LiveTvAPIGetLiveRecordingFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveRecordingFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveRecordings/{recordingId}/stream"
	localVarPath = strings.Replace(localVarPath, "{"+"recordingId"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"video/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetLiveStreamFileRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	streamId string
	container string
}

func (r LiveTvAPIGetLiveStreamFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLiveStreamFileExecute(r)
}

/*
GetLiveStreamFile Gets a live tv channel stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamId Stream id.
 @param container Container type.
 @return LiveTvAPIGetLiveStreamFileRequest
*/
func (a *LiveTvAPIService) GetLiveStreamFile(ctx context.Context, streamId string, container string) LiveTvAPIGetLiveStreamFileRequest {
	return LiveTvAPIGetLiveStreamFileRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
		container: container,
	}
}

// Execute executes the request
//  @return *os.File
func (a *LiveTvAPIService) GetLiveStreamFileExecute(r LiveTvAPIGetLiveStreamFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveStreamFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveStreamFiles/{streamId}/stream.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"video/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetLiveTvChannelsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	type_ *JellyfinChannelType
	userId *string
	startIndex *int32
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	limit *int32
	isFavorite *bool
	isLiked *bool
	isDisliked *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]JellyfinImageType
	fields *[]JellyfinItemFields
	enableUserData *bool
	sortBy *[]JellyfinItemSortBy
	sortOrder *JellyfinSortOrder
	enableFavoriteSorting *bool
	addCurrentProgram *bool
}

// Optional. Filter by channel type.
func (r LiveTvAPIGetLiveTvChannelsRequest) Type_(type_ JellyfinChannelType) LiveTvAPIGetLiveTvChannelsRequest {
	r.type_ = &type_
	return r
}

// Optional. Filter by user and attach user data.
func (r LiveTvAPIGetLiveTvChannelsRequest) UserId(userId string) LiveTvAPIGetLiveTvChannelsRequest {
	r.userId = &userId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvAPIGetLiveTvChannelsRequest) StartIndex(startIndex int32) LiveTvAPIGetLiveTvChannelsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. Filter for movies.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsMovie(isMovie bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for series.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsSeries(isSeries bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for news.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsNews(isNews bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for kids.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsKids(isKids bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsSports(isSports bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isSports = &isSports
	return r
}

// Optional. The maximum number of records to return.
func (r LiveTvAPIGetLiveTvChannelsRequest) Limit(limit int32) LiveTvAPIGetLiveTvChannelsRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by channels that are favorites, or not.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsFavorite(isFavorite bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional. Filter by channels that are liked, or not.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsLiked(isLiked bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isLiked = &isLiked
	return r
}

// Optional. Filter by channels that are disliked, or not.
func (r LiveTvAPIGetLiveTvChannelsRequest) IsDisliked(isDisliked bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.isDisliked = &isDisliked
	return r
}

// Optional. Include image information in output.
func (r LiveTvAPIGetLiveTvChannelsRequest) EnableImages(enableImages bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r LiveTvAPIGetLiveTvChannelsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvAPIGetLiveTvChannelsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// \&quot;Optional. The image types to include in the output.
func (r LiveTvAPIGetLiveTvChannelsRequest) EnableImageTypes(enableImageTypes []JellyfinImageType) LiveTvAPIGetLiveTvChannelsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r LiveTvAPIGetLiveTvChannelsRequest) Fields(fields []JellyfinItemFields) LiveTvAPIGetLiveTvChannelsRequest {
	r.fields = &fields
	return r
}

// Optional. Include user data.
func (r LiveTvAPIGetLiveTvChannelsRequest) EnableUserData(enableUserData bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Key to sort by.
func (r LiveTvAPIGetLiveTvChannelsRequest) SortBy(sortBy []JellyfinItemSortBy) LiveTvAPIGetLiveTvChannelsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional. Sort order.
func (r LiveTvAPIGetLiveTvChannelsRequest) SortOrder(sortOrder JellyfinSortOrder) LiveTvAPIGetLiveTvChannelsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional. Incorporate favorite and like status into channel sorting.
func (r LiveTvAPIGetLiveTvChannelsRequest) EnableFavoriteSorting(enableFavoriteSorting bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.enableFavoriteSorting = &enableFavoriteSorting
	return r
}

// Optional. Adds current program info to each channel.
func (r LiveTvAPIGetLiveTvChannelsRequest) AddCurrentProgram(addCurrentProgram bool) LiveTvAPIGetLiveTvChannelsRequest {
	r.addCurrentProgram = &addCurrentProgram
	return r
}

func (r LiveTvAPIGetLiveTvChannelsRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetLiveTvChannelsExecute(r)
}

/*
GetLiveTvChannels Gets available live tv channels.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetLiveTvChannelsRequest
*/
func (a *LiveTvAPIService) GetLiveTvChannels(ctx context.Context) LiveTvAPIGetLiveTvChannelsRequest {
	return LiveTvAPIGetLiveTvChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
func (a *LiveTvAPIService) GetLiveTvChannelsExecute(r LiveTvAPIGetLiveTvChannelsRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveTvChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFavorite", r.isFavorite, "form", "")
	}
	if r.isLiked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLiked", r.isLiked, "form", "")
	}
	if r.isDisliked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDisliked", r.isDisliked, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	if r.enableFavoriteSorting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableFavoriteSorting", r.enableFavoriteSorting, "form", "")
	} else {
		var defaultValue bool = false
		r.enableFavoriteSorting = &defaultValue
	}
	if r.addCurrentProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addCurrentProgram", r.addCurrentProgram, "form", "")
	} else {
		var defaultValue bool = true
		r.addCurrentProgram = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetLiveTvInfoRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
}

func (r LiveTvAPIGetLiveTvInfoRequest) Execute() (*JellyfinLiveTvInfo, *http.Response, error) {
	return r.ApiService.GetLiveTvInfoExecute(r)
}

/*
GetLiveTvInfo Gets available live tv services.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetLiveTvInfoRequest
*/
func (a *LiveTvAPIService) GetLiveTvInfo(ctx context.Context) LiveTvAPIGetLiveTvInfoRequest {
	return LiveTvAPIGetLiveTvInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinLiveTvInfo
func (a *LiveTvAPIService) GetLiveTvInfoExecute(r LiveTvAPIGetLiveTvInfoRequest) (*JellyfinLiveTvInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinLiveTvInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveTvInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetLiveTvProgramsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	channelIds *[]string
	userId *string
	minStartDate *time.Time
	hasAired *bool
	isAiring *bool
	maxStartDate *time.Time
	minEndDate *time.Time
	maxEndDate *time.Time
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	startIndex *int32
	limit *int32
	sortBy *[]JellyfinItemSortBy
	sortOrder *[]JellyfinSortOrder
	genres *[]string
	genreIds *[]string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]JellyfinImageType
	enableUserData *bool
	seriesTimerId *string
	librarySeriesId *string
	fields *[]JellyfinItemFields
	enableTotalRecordCount *bool
}

// The channels to return guide information for.
func (r LiveTvAPIGetLiveTvProgramsRequest) ChannelIds(channelIds []string) LiveTvAPIGetLiveTvProgramsRequest {
	r.channelIds = &channelIds
	return r
}

// Optional. Filter by user id.
func (r LiveTvAPIGetLiveTvProgramsRequest) UserId(userId string) LiveTvAPIGetLiveTvProgramsRequest {
	r.userId = &userId
	return r
}

// Optional. The minimum premiere start date.
func (r LiveTvAPIGetLiveTvProgramsRequest) MinStartDate(minStartDate time.Time) LiveTvAPIGetLiveTvProgramsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r LiveTvAPIGetLiveTvProgramsRequest) HasAired(hasAired bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.hasAired = &hasAired
	return r
}

// Optional. Filter by programs that are currently airing, or not.
func (r LiveTvAPIGetLiveTvProgramsRequest) IsAiring(isAiring bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.isAiring = &isAiring
	return r
}

// Optional. The maximum premiere start date.
func (r LiveTvAPIGetLiveTvProgramsRequest) MaxStartDate(maxStartDate time.Time) LiveTvAPIGetLiveTvProgramsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere end date.
func (r LiveTvAPIGetLiveTvProgramsRequest) MinEndDate(minEndDate time.Time) LiveTvAPIGetLiveTvProgramsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere end date.
func (r LiveTvAPIGetLiveTvProgramsRequest) MaxEndDate(maxEndDate time.Time) LiveTvAPIGetLiveTvProgramsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional. Filter for movies.
func (r LiveTvAPIGetLiveTvProgramsRequest) IsMovie(isMovie bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for series.
func (r LiveTvAPIGetLiveTvProgramsRequest) IsSeries(isSeries bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for news.
func (r LiveTvAPIGetLiveTvProgramsRequest) IsNews(isNews bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for kids.
func (r LiveTvAPIGetLiveTvProgramsRequest) IsKids(isKids bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r LiveTvAPIGetLiveTvProgramsRequest) IsSports(isSports bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvAPIGetLiveTvProgramsRequest) StartIndex(startIndex int32) LiveTvAPIGetLiveTvProgramsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r LiveTvAPIGetLiveTvProgramsRequest) Limit(limit int32) LiveTvAPIGetLiveTvProgramsRequest {
	r.limit = &limit
	return r
}

// Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
func (r LiveTvAPIGetLiveTvProgramsRequest) SortBy(sortBy []JellyfinItemSortBy) LiveTvAPIGetLiveTvProgramsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort Order - Ascending,Descending.
func (r LiveTvAPIGetLiveTvProgramsRequest) SortOrder(sortOrder []JellyfinSortOrder) LiveTvAPIGetLiveTvProgramsRequest {
	r.sortOrder = &sortOrder
	return r
}

// The genres to return guide information for.
func (r LiveTvAPIGetLiveTvProgramsRequest) Genres(genres []string) LiveTvAPIGetLiveTvProgramsRequest {
	r.genres = &genres
	return r
}

// The genre ids to return guide information for.
func (r LiveTvAPIGetLiveTvProgramsRequest) GenreIds(genreIds []string) LiveTvAPIGetLiveTvProgramsRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Include image information in output.
func (r LiveTvAPIGetLiveTvProgramsRequest) EnableImages(enableImages bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r LiveTvAPIGetLiveTvProgramsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvAPIGetLiveTvProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvAPIGetLiveTvProgramsRequest) EnableImageTypes(enableImageTypes []JellyfinImageType) LiveTvAPIGetLiveTvProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Include user data.
func (r LiveTvAPIGetLiveTvProgramsRequest) EnableUserData(enableUserData bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Filter by series timer id.
func (r LiveTvAPIGetLiveTvProgramsRequest) SeriesTimerId(seriesTimerId string) LiveTvAPIGetLiveTvProgramsRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Filter by library series id.
func (r LiveTvAPIGetLiveTvProgramsRequest) LibrarySeriesId(librarySeriesId string) LiveTvAPIGetLiveTvProgramsRequest {
	r.librarySeriesId = &librarySeriesId
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r LiveTvAPIGetLiveTvProgramsRequest) Fields(fields []JellyfinItemFields) LiveTvAPIGetLiveTvProgramsRequest {
	r.fields = &fields
	return r
}

// Retrieve total record count.
func (r LiveTvAPIGetLiveTvProgramsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) LiveTvAPIGetLiveTvProgramsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r LiveTvAPIGetLiveTvProgramsRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetLiveTvProgramsExecute(r)
}

/*
GetLiveTvPrograms Gets available live tv epgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetLiveTvProgramsRequest
*/
func (a *LiveTvAPIService) GetLiveTvPrograms(ctx context.Context) LiveTvAPIGetLiveTvProgramsRequest {
	return LiveTvAPIGetLiveTvProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
func (a *LiveTvAPIService) GetLiveTvProgramsExecute(r LiveTvAPIGetLiveTvProgramsRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveTvPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelIds != nil {
		t := *r.channelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelIds", t, "form", "multi")
		}
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minStartDate", r.minStartDate, "form", "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAired", r.hasAired, "form", "")
	}
	if r.isAiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isAiring", r.isAiring, "form", "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStartDate", r.maxStartDate, "form", "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minEndDate", r.minEndDate, "form", "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxEndDate", r.maxEndDate, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "form", "multi")
		}
	}
	if r.genres != nil {
		t := *r.genres
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genres", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genres", t, "form", "multi")
		}
	}
	if r.genreIds != nil {
		t := *r.genreIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", t, "form", "multi")
		}
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.librarySeriesId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "librarySeriesId", r.librarySeriesId, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetProgramRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	programId string
	userId *string
}

// Optional. Attach user data.
func (r LiveTvAPIGetProgramRequest) UserId(userId string) LiveTvAPIGetProgramRequest {
	r.userId = &userId
	return r
}

func (r LiveTvAPIGetProgramRequest) Execute() (*JellyfinBaseItemDto, *http.Response, error) {
	return r.ApiService.GetProgramExecute(r)
}

/*
GetProgram Gets a live tv program.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param programId Program id.
 @return LiveTvAPIGetProgramRequest
*/
func (a *LiveTvAPIService) GetProgram(ctx context.Context, programId string) LiveTvAPIGetProgramRequest {
	return LiveTvAPIGetProgramRequest{
		ApiService: a,
		ctx: ctx,
		programId: programId,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDto
func (a *LiveTvAPIService) GetProgramExecute(r LiveTvAPIGetProgramRequest) (*JellyfinBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetProgram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs/{programId}"
	localVarPath = strings.Replace(localVarPath, "{"+"programId"+"}", url.PathEscape(parameterValueToString(r.programId, "programId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetProgramsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	jellyfinGetProgramsDto *JellyfinGetProgramsDto
}

// Request body.
func (r LiveTvAPIGetProgramsRequest) JellyfinGetProgramsDto(jellyfinGetProgramsDto JellyfinGetProgramsDto) LiveTvAPIGetProgramsRequest {
	r.jellyfinGetProgramsDto = &jellyfinGetProgramsDto
	return r
}

func (r LiveTvAPIGetProgramsRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetProgramsExecute(r)
}

/*
GetPrograms Gets available live tv epgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetProgramsRequest
*/
func (a *LiveTvAPIService) GetPrograms(ctx context.Context) LiveTvAPIGetProgramsRequest {
	return LiveTvAPIGetProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
func (a *LiveTvAPIService) GetProgramsExecute(r LiveTvAPIGetProgramsRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinGetProgramsDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetRecommendedProgramsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	userId *string
	limit *int32
	isAiring *bool
	hasAired *bool
	isSeries *bool
	isMovie *bool
	isNews *bool
	isKids *bool
	isSports *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]JellyfinImageType
	genreIds *[]string
	fields *[]JellyfinItemFields
	enableUserData *bool
	enableTotalRecordCount *bool
}

// Optional. filter by user id.
func (r LiveTvAPIGetRecommendedProgramsRequest) UserId(userId string) LiveTvAPIGetRecommendedProgramsRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return.
func (r LiveTvAPIGetRecommendedProgramsRequest) Limit(limit int32) LiveTvAPIGetRecommendedProgramsRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by programs that are currently airing, or not.
func (r LiveTvAPIGetRecommendedProgramsRequest) IsAiring(isAiring bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.isAiring = &isAiring
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r LiveTvAPIGetRecommendedProgramsRequest) HasAired(hasAired bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.hasAired = &hasAired
	return r
}

// Optional. Filter for series.
func (r LiveTvAPIGetRecommendedProgramsRequest) IsSeries(isSeries bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for movies.
func (r LiveTvAPIGetRecommendedProgramsRequest) IsMovie(isMovie bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for news.
func (r LiveTvAPIGetRecommendedProgramsRequest) IsNews(isNews bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for kids.
func (r LiveTvAPIGetRecommendedProgramsRequest) IsKids(isKids bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r LiveTvAPIGetRecommendedProgramsRequest) IsSports(isSports bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional. Include image information in output.
func (r LiveTvAPIGetRecommendedProgramsRequest) EnableImages(enableImages bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r LiveTvAPIGetRecommendedProgramsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvAPIGetRecommendedProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvAPIGetRecommendedProgramsRequest) EnableImageTypes(enableImageTypes []JellyfinImageType) LiveTvAPIGetRecommendedProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// The genres to return guide information for.
func (r LiveTvAPIGetRecommendedProgramsRequest) GenreIds(genreIds []string) LiveTvAPIGetRecommendedProgramsRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r LiveTvAPIGetRecommendedProgramsRequest) Fields(fields []JellyfinItemFields) LiveTvAPIGetRecommendedProgramsRequest {
	r.fields = &fields
	return r
}

// Optional. include user data.
func (r LiveTvAPIGetRecommendedProgramsRequest) EnableUserData(enableUserData bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Retrieve total record count.
func (r LiveTvAPIGetRecommendedProgramsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) LiveTvAPIGetRecommendedProgramsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r LiveTvAPIGetRecommendedProgramsRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecommendedProgramsExecute(r)
}

/*
GetRecommendedPrograms Gets recommended live tv epgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetRecommendedProgramsRequest
*/
func (a *LiveTvAPIService) GetRecommendedPrograms(ctx context.Context) LiveTvAPIGetRecommendedProgramsRequest {
	return LiveTvAPIGetRecommendedProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
func (a *LiveTvAPIService) GetRecommendedProgramsExecute(r LiveTvAPIGetRecommendedProgramsRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecommendedPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs/Recommended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.isAiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isAiring", r.isAiring, "form", "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAired", r.hasAired, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.genreIds != nil {
		t := *r.genreIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetRecordingRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	recordingId string
	userId *string
}

// Optional. Attach user data.
func (r LiveTvAPIGetRecordingRequest) UserId(userId string) LiveTvAPIGetRecordingRequest {
	r.userId = &userId
	return r
}

func (r LiveTvAPIGetRecordingRequest) Execute() (*JellyfinBaseItemDto, *http.Response, error) {
	return r.ApiService.GetRecordingExecute(r)
}

/*
GetRecording Gets a live tv recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordingId Recording id.
 @return LiveTvAPIGetRecordingRequest
*/
func (a *LiveTvAPIService) GetRecording(ctx context.Context, recordingId string) LiveTvAPIGetRecordingRequest {
	return LiveTvAPIGetRecordingRequest{
		ApiService: a,
		ctx: ctx,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDto
func (a *LiveTvAPIService) GetRecordingExecute(r LiveTvAPIGetRecordingRequest) (*JellyfinBaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{recordingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"recordingId"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetRecordingFoldersRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	userId *string
}

// Optional. Filter by user and attach user data.
func (r LiveTvAPIGetRecordingFoldersRequest) UserId(userId string) LiveTvAPIGetRecordingFoldersRequest {
	r.userId = &userId
	return r
}

func (r LiveTvAPIGetRecordingFoldersRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingFoldersExecute(r)
}

/*
GetRecordingFolders Gets recording folders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetRecordingFoldersRequest
*/
func (a *LiveTvAPIService) GetRecordingFolders(ctx context.Context) LiveTvAPIGetRecordingFoldersRequest {
	return LiveTvAPIGetRecordingFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
func (a *LiveTvAPIService) GetRecordingFoldersExecute(r LiveTvAPIGetRecordingFoldersRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetRecordingGroupRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	groupId string
}

func (r LiveTvAPIGetRecordingGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRecordingGroupExecute(r)
}

/*
GetRecordingGroup Get recording group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Group id.
 @return LiveTvAPIGetRecordingGroupRequest

Deprecated
*/
func (a *LiveTvAPIService) GetRecordingGroup(ctx context.Context, groupId string) LiveTvAPIGetRecordingGroupRequest {
	return LiveTvAPIGetRecordingGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
// Deprecated
func (a *LiveTvAPIService) GetRecordingGroupExecute(r LiveTvAPIGetRecordingGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPIGetRecordingGroupsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	userId *string
}

// Optional. Filter by user and attach user data.
func (r LiveTvAPIGetRecordingGroupsRequest) UserId(userId string) LiveTvAPIGetRecordingGroupsRequest {
	r.userId = &userId
	return r
}

func (r LiveTvAPIGetRecordingGroupsRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingGroupsExecute(r)
}

/*
GetRecordingGroups Gets live tv recording groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetRecordingGroupsRequest

Deprecated
*/
func (a *LiveTvAPIService) GetRecordingGroups(ctx context.Context) LiveTvAPIGetRecordingGroupsRequest {
	return LiveTvAPIGetRecordingGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
// Deprecated
func (a *LiveTvAPIService) GetRecordingGroupsExecute(r LiveTvAPIGetRecordingGroupsRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetRecordingsRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	channelId *string
	userId *string
	startIndex *int32
	limit *int32
	status *JellyfinRecordingStatus
	isInProgress *bool
	seriesTimerId *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]JellyfinImageType
	fields *[]JellyfinItemFields
	enableUserData *bool
	isMovie *bool
	isSeries *bool
	isKids *bool
	isSports *bool
	isNews *bool
	isLibraryItem *bool
	enableTotalRecordCount *bool
}

// Optional. Filter by channel id.
func (r LiveTvAPIGetRecordingsRequest) ChannelId(channelId string) LiveTvAPIGetRecordingsRequest {
	r.channelId = &channelId
	return r
}

// Optional. Filter by user and attach user data.
func (r LiveTvAPIGetRecordingsRequest) UserId(userId string) LiveTvAPIGetRecordingsRequest {
	r.userId = &userId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvAPIGetRecordingsRequest) StartIndex(startIndex int32) LiveTvAPIGetRecordingsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r LiveTvAPIGetRecordingsRequest) Limit(limit int32) LiveTvAPIGetRecordingsRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by recording status.
func (r LiveTvAPIGetRecordingsRequest) Status(status JellyfinRecordingStatus) LiveTvAPIGetRecordingsRequest {
	r.status = &status
	return r
}

// Optional. Filter by recordings that are in progress, or not.
func (r LiveTvAPIGetRecordingsRequest) IsInProgress(isInProgress bool) LiveTvAPIGetRecordingsRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional. Filter by recordings belonging to a series timer.
func (r LiveTvAPIGetRecordingsRequest) SeriesTimerId(seriesTimerId string) LiveTvAPIGetRecordingsRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Include image information in output.
func (r LiveTvAPIGetRecordingsRequest) EnableImages(enableImages bool) LiveTvAPIGetRecordingsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r LiveTvAPIGetRecordingsRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvAPIGetRecordingsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvAPIGetRecordingsRequest) EnableImageTypes(enableImageTypes []JellyfinImageType) LiveTvAPIGetRecordingsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r LiveTvAPIGetRecordingsRequest) Fields(fields []JellyfinItemFields) LiveTvAPIGetRecordingsRequest {
	r.fields = &fields
	return r
}

// Optional. Include user data.
func (r LiveTvAPIGetRecordingsRequest) EnableUserData(enableUserData bool) LiveTvAPIGetRecordingsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Filter for movies.
func (r LiveTvAPIGetRecordingsRequest) IsMovie(isMovie bool) LiveTvAPIGetRecordingsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for series.
func (r LiveTvAPIGetRecordingsRequest) IsSeries(isSeries bool) LiveTvAPIGetRecordingsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for kids.
func (r LiveTvAPIGetRecordingsRequest) IsKids(isKids bool) LiveTvAPIGetRecordingsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r LiveTvAPIGetRecordingsRequest) IsSports(isSports bool) LiveTvAPIGetRecordingsRequest {
	r.isSports = &isSports
	return r
}

// Optional. Filter for news.
func (r LiveTvAPIGetRecordingsRequest) IsNews(isNews bool) LiveTvAPIGetRecordingsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for is library item.
func (r LiveTvAPIGetRecordingsRequest) IsLibraryItem(isLibraryItem bool) LiveTvAPIGetRecordingsRequest {
	r.isLibraryItem = &isLibraryItem
	return r
}

// Optional. Return total record count.
func (r LiveTvAPIGetRecordingsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) LiveTvAPIGetRecordingsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r LiveTvAPIGetRecordingsRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingsExecute(r)
}

/*
GetRecordings Gets live tv recordings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetRecordingsRequest
*/
func (a *LiveTvAPIService) GetRecordings(ctx context.Context) LiveTvAPIGetRecordingsRequest {
	return LiveTvAPIGetRecordingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
func (a *LiveTvAPIService) GetRecordingsExecute(r LiveTvAPIGetRecordingsRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", r.channelId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isInProgress", r.isInProgress, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isLibraryItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLibraryItem", r.isLibraryItem, "form", "")
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetRecordingsSeriesRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	channelId *string
	userId *string
	groupId *string
	startIndex *int32
	limit *int32
	status *JellyfinRecordingStatus
	isInProgress *bool
	seriesTimerId *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]JellyfinImageType
	fields *[]JellyfinItemFields
	enableUserData *bool
	enableTotalRecordCount *bool
}

// Optional. Filter by channel id.
func (r LiveTvAPIGetRecordingsSeriesRequest) ChannelId(channelId string) LiveTvAPIGetRecordingsSeriesRequest {
	r.channelId = &channelId
	return r
}

// Optional. Filter by user and attach user data.
func (r LiveTvAPIGetRecordingsSeriesRequest) UserId(userId string) LiveTvAPIGetRecordingsSeriesRequest {
	r.userId = &userId
	return r
}

// Optional. Filter by recording group.
func (r LiveTvAPIGetRecordingsSeriesRequest) GroupId(groupId string) LiveTvAPIGetRecordingsSeriesRequest {
	r.groupId = &groupId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r LiveTvAPIGetRecordingsSeriesRequest) StartIndex(startIndex int32) LiveTvAPIGetRecordingsSeriesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r LiveTvAPIGetRecordingsSeriesRequest) Limit(limit int32) LiveTvAPIGetRecordingsSeriesRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by recording status.
func (r LiveTvAPIGetRecordingsSeriesRequest) Status(status JellyfinRecordingStatus) LiveTvAPIGetRecordingsSeriesRequest {
	r.status = &status
	return r
}

// Optional. Filter by recordings that are in progress, or not.
func (r LiveTvAPIGetRecordingsSeriesRequest) IsInProgress(isInProgress bool) LiveTvAPIGetRecordingsSeriesRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional. Filter by recordings belonging to a series timer.
func (r LiveTvAPIGetRecordingsSeriesRequest) SeriesTimerId(seriesTimerId string) LiveTvAPIGetRecordingsSeriesRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Include image information in output.
func (r LiveTvAPIGetRecordingsSeriesRequest) EnableImages(enableImages bool) LiveTvAPIGetRecordingsSeriesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r LiveTvAPIGetRecordingsSeriesRequest) ImageTypeLimit(imageTypeLimit int32) LiveTvAPIGetRecordingsSeriesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r LiveTvAPIGetRecordingsSeriesRequest) EnableImageTypes(enableImageTypes []JellyfinImageType) LiveTvAPIGetRecordingsSeriesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r LiveTvAPIGetRecordingsSeriesRequest) Fields(fields []JellyfinItemFields) LiveTvAPIGetRecordingsSeriesRequest {
	r.fields = &fields
	return r
}

// Optional. Include user data.
func (r LiveTvAPIGetRecordingsSeriesRequest) EnableUserData(enableUserData bool) LiveTvAPIGetRecordingsSeriesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Return total record count.
func (r LiveTvAPIGetRecordingsSeriesRequest) EnableTotalRecordCount(enableTotalRecordCount bool) LiveTvAPIGetRecordingsSeriesRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r LiveTvAPIGetRecordingsSeriesRequest) Execute() (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingsSeriesExecute(r)
}

/*
GetRecordingsSeries Gets live tv recording series.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetRecordingsSeriesRequest

Deprecated
*/
func (a *LiveTvAPIService) GetRecordingsSeries(ctx context.Context) LiveTvAPIGetRecordingsSeriesRequest {
	return LiveTvAPIGetRecordingsSeriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinBaseItemDtoQueryResult
// Deprecated
func (a *LiveTvAPIService) GetRecordingsSeriesExecute(r LiveTvAPIGetRecordingsSeriesRequest) (*JellyfinBaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinBaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingsSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", r.channelId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isInProgress", r.isInProgress, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetSchedulesDirectCountriesRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
}

func (r LiveTvAPIGetSchedulesDirectCountriesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetSchedulesDirectCountriesExecute(r)
}

/*
GetSchedulesDirectCountries Gets available countries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetSchedulesDirectCountriesRequest
*/
func (a *LiveTvAPIService) GetSchedulesDirectCountries(ctx context.Context) LiveTvAPIGetSchedulesDirectCountriesRequest {
	return LiveTvAPIGetSchedulesDirectCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *LiveTvAPIService) GetSchedulesDirectCountriesExecute(r LiveTvAPIGetSchedulesDirectCountriesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetSchedulesDirectCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/SchedulesDirect/Countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetSeriesTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	timerId string
}

func (r LiveTvAPIGetSeriesTimerRequest) Execute() (*JellyfinSeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetSeriesTimerExecute(r)
}

/*
GetSeriesTimer Gets a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return LiveTvAPIGetSeriesTimerRequest
*/
func (a *LiveTvAPIService) GetSeriesTimer(ctx context.Context, timerId string) LiveTvAPIGetSeriesTimerRequest {
	return LiveTvAPIGetSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
//  @return JellyfinSeriesTimerInfoDto
func (a *LiveTvAPIService) GetSeriesTimerExecute(r LiveTvAPIGetSeriesTimerRequest) (*JellyfinSeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinSeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetSeriesTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetSeriesTimersRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	sortBy *string
	sortOrder *JellyfinSortOrder
}

// Optional. Sort by SortName or Priority.
func (r LiveTvAPIGetSeriesTimersRequest) SortBy(sortBy string) LiveTvAPIGetSeriesTimersRequest {
	r.sortBy = &sortBy
	return r
}

// Optional. Sort in Ascending or Descending order.
func (r LiveTvAPIGetSeriesTimersRequest) SortOrder(sortOrder JellyfinSortOrder) LiveTvAPIGetSeriesTimersRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r LiveTvAPIGetSeriesTimersRequest) Execute() (*JellyfinSeriesTimerInfoDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetSeriesTimersExecute(r)
}

/*
GetSeriesTimers Gets live tv series timers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetSeriesTimersRequest
*/
func (a *LiveTvAPIService) GetSeriesTimers(ctx context.Context) LiveTvAPIGetSeriesTimersRequest {
	return LiveTvAPIGetSeriesTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinSeriesTimerInfoDtoQueryResult
func (a *LiveTvAPIService) GetSeriesTimersExecute(r LiveTvAPIGetSeriesTimersRequest) (*JellyfinSeriesTimerInfoDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinSeriesTimerInfoDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetSeriesTimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	timerId string
}

func (r LiveTvAPIGetTimerRequest) Execute() (*JellyfinTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetTimerExecute(r)
}

/*
GetTimer Gets a timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return LiveTvAPIGetTimerRequest
*/
func (a *LiveTvAPIService) GetTimer(ctx context.Context, timerId string) LiveTvAPIGetTimerRequest {
	return LiveTvAPIGetTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
//  @return JellyfinTimerInfoDto
func (a *LiveTvAPIService) GetTimerExecute(r LiveTvAPIGetTimerRequest) (*JellyfinTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetTimersRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	channelId *string
	seriesTimerId *string
	isActive *bool
	isScheduled *bool
}

// Optional. Filter by channel id.
func (r LiveTvAPIGetTimersRequest) ChannelId(channelId string) LiveTvAPIGetTimersRequest {
	r.channelId = &channelId
	return r
}

// Optional. Filter by timers belonging to a series timer.
func (r LiveTvAPIGetTimersRequest) SeriesTimerId(seriesTimerId string) LiveTvAPIGetTimersRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Filter by timers that are active.
func (r LiveTvAPIGetTimersRequest) IsActive(isActive bool) LiveTvAPIGetTimersRequest {
	r.isActive = &isActive
	return r
}

// Optional. Filter by timers that are scheduled.
func (r LiveTvAPIGetTimersRequest) IsScheduled(isScheduled bool) LiveTvAPIGetTimersRequest {
	r.isScheduled = &isScheduled
	return r
}

func (r LiveTvAPIGetTimersRequest) Execute() (*JellyfinTimerInfoDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetTimersExecute(r)
}

/*
GetTimers Gets the live tv timers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetTimersRequest
*/
func (a *LiveTvAPIService) GetTimers(ctx context.Context) LiveTvAPIGetTimersRequest {
	return LiveTvAPIGetTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinTimerInfoDtoQueryResult
func (a *LiveTvAPIService) GetTimersExecute(r LiveTvAPIGetTimersRequest) (*JellyfinTimerInfoDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinTimerInfoDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetTimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", r.channelId, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.isActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isActive", r.isActive, "form", "")
	}
	if r.isScheduled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isScheduled", r.isScheduled, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIGetTunerHostTypesRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
}

func (r LiveTvAPIGetTunerHostTypesRequest) Execute() ([]JellyfinNameIdPair, *http.Response, error) {
	return r.ApiService.GetTunerHostTypesExecute(r)
}

/*
GetTunerHostTypes Get tuner host types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPIGetTunerHostTypesRequest
*/
func (a *LiveTvAPIService) GetTunerHostTypes(ctx context.Context) LiveTvAPIGetTunerHostTypesRequest {
	return LiveTvAPIGetTunerHostTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinNameIdPair
func (a *LiveTvAPIService) GetTunerHostTypesExecute(r LiveTvAPIGetTunerHostTypesRequest) ([]JellyfinNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetTunerHostTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIResetTunerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	tunerId string
}

func (r LiveTvAPIResetTunerRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResetTunerExecute(r)
}

/*
ResetTuner Resets a tv tuner.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tunerId Tuner id.
 @return LiveTvAPIResetTunerRequest
*/
func (a *LiveTvAPIService) ResetTuner(ctx context.Context, tunerId string) LiveTvAPIResetTunerRequest {
	return LiveTvAPIResetTunerRequest{
		ApiService: a,
		ctx: ctx,
		tunerId: tunerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) ResetTunerExecute(r LiveTvAPIResetTunerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.ResetTuner")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/{tunerId}/Reset"
	localVarPath = strings.Replace(localVarPath, "{"+"tunerId"+"}", url.PathEscape(parameterValueToString(r.tunerId, "tunerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPISetChannelMappingRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	jellyfinSetChannelMappingDto *JellyfinSetChannelMappingDto
}

// The set channel mapping dto.
func (r LiveTvAPISetChannelMappingRequest) JellyfinSetChannelMappingDto(jellyfinSetChannelMappingDto JellyfinSetChannelMappingDto) LiveTvAPISetChannelMappingRequest {
	r.jellyfinSetChannelMappingDto = &jellyfinSetChannelMappingDto
	return r
}

func (r LiveTvAPISetChannelMappingRequest) Execute() (*JellyfinTunerChannelMapping, *http.Response, error) {
	return r.ApiService.SetChannelMappingExecute(r)
}

/*
SetChannelMapping Set channel mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return LiveTvAPISetChannelMappingRequest
*/
func (a *LiveTvAPIService) SetChannelMapping(ctx context.Context) LiveTvAPISetChannelMappingRequest {
	return LiveTvAPISetChannelMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JellyfinTunerChannelMapping
func (a *LiveTvAPIService) SetChannelMappingExecute(r LiveTvAPISetChannelMappingRequest) (*JellyfinTunerChannelMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JellyfinTunerChannelMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.SetChannelMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinSetChannelMappingDto == nil {
		return localVarReturnValue, nil, reportError("jellyfinSetChannelMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSetChannelMappingDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LiveTvAPIUpdateSeriesTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	timerId string
	jellyfinSeriesTimerInfoDto *JellyfinSeriesTimerInfoDto
}

// New series timer info.
func (r LiveTvAPIUpdateSeriesTimerRequest) JellyfinSeriesTimerInfoDto(jellyfinSeriesTimerInfoDto JellyfinSeriesTimerInfoDto) LiveTvAPIUpdateSeriesTimerRequest {
	r.jellyfinSeriesTimerInfoDto = &jellyfinSeriesTimerInfoDto
	return r
}

func (r LiveTvAPIUpdateSeriesTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSeriesTimerExecute(r)
}

/*
UpdateSeriesTimer Updates a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return LiveTvAPIUpdateSeriesTimerRequest
*/
func (a *LiveTvAPIService) UpdateSeriesTimer(ctx context.Context, timerId string) LiveTvAPIUpdateSeriesTimerRequest {
	return LiveTvAPIUpdateSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) UpdateSeriesTimerExecute(r LiveTvAPIUpdateSeriesTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.UpdateSeriesTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinSeriesTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type LiveTvAPIUpdateTimerRequest struct {
	ctx context.Context
	ApiService *LiveTvAPIService
	timerId string
	jellyfinTimerInfoDto *JellyfinTimerInfoDto
}

// New timer info.
func (r LiveTvAPIUpdateTimerRequest) JellyfinTimerInfoDto(jellyfinTimerInfoDto JellyfinTimerInfoDto) LiveTvAPIUpdateTimerRequest {
	r.jellyfinTimerInfoDto = &jellyfinTimerInfoDto
	return r
}

func (r LiveTvAPIUpdateTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTimerExecute(r)
}

/*
UpdateTimer Updates a live tv timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return LiveTvAPIUpdateTimerRequest
*/
func (a *LiveTvAPIService) UpdateTimer(ctx context.Context, timerId string) LiveTvAPIUpdateTimerRequest {
	return LiveTvAPIUpdateTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) UpdateTimerExecute(r LiveTvAPIUpdateTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.UpdateTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

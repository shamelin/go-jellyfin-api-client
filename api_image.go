/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jellyfin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ImageAPIService ImageAPI service
type ImageAPIService service

type ImageAPIDeleteCustomSplashscreenRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
}

func (r ImageAPIDeleteCustomSplashscreenRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomSplashscreenExecute(r)
}

/*
DeleteCustomSplashscreen Delete a custom splashscreen.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIDeleteCustomSplashscreenRequest
*/
func (a *ImageAPIService) DeleteCustomSplashscreen(ctx context.Context) ImageAPIDeleteCustomSplashscreenRequest {
	return ImageAPIDeleteCustomSplashscreenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteCustomSplashscreenExecute(r ImageAPIDeleteCustomSplashscreenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteCustomSplashscreen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Branding/Splashscreen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPIDeleteItemImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	imageIndex *int32
}

// The image index.
func (r ImageAPIDeleteItemImageRequest) ImageIndex(imageIndex int32) ImageAPIDeleteItemImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIDeleteItemImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemImageExecute(r)
}

/*
DeleteItemImage Delete an item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ImageAPIDeleteItemImageRequest
*/
func (a *ImageAPIService) DeleteItemImage(ctx context.Context, itemId string, imageType JellyfinImageType) ImageAPIDeleteItemImageRequest {
	return ImageAPIDeleteItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteItemImageExecute(r ImageAPIDeleteItemImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteItemImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPIDeleteItemImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	imageIndex int32
}

func (r ImageAPIDeleteItemImageByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemImageByIndexExecute(r)
}

/*
DeleteItemImageByIndex Delete an item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex The image index.
 @return ImageAPIDeleteItemImageByIndexRequest
*/
func (a *ImageAPIService) DeleteItemImageByIndex(ctx context.Context, itemId string, imageType JellyfinImageType, imageIndex int32) ImageAPIDeleteItemImageByIndexRequest {
	return ImageAPIDeleteItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteItemImageByIndexExecute(r ImageAPIDeleteItemImageByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteItemImageByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPIDeleteUserImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	userId *string
}

// User Id.
func (r ImageAPIDeleteUserImageRequest) UserId(userId string) ImageAPIDeleteUserImageRequest {
	r.userId = &userId
	return r
}

func (r ImageAPIDeleteUserImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserImageExecute(r)
}

/*
DeleteUserImage Delete the user's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIDeleteUserImageRequest
*/
func (a *ImageAPIService) DeleteUserImage(ctx context.Context) ImageAPIDeleteUserImageRequest {
	return ImageAPIDeleteUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteUserImageExecute(r ImageAPIDeleteUserImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteUserImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPIGetArtistImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetArtistImageRequest) Tag(tag string) ImageAPIGetArtistImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetArtistImageRequest) Format(format JellyfinImageFormat) ImageAPIGetArtistImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetArtistImageRequest) MaxWidth(maxWidth int32) ImageAPIGetArtistImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetArtistImageRequest) MaxHeight(maxHeight int32) ImageAPIGetArtistImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetArtistImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetArtistImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetArtistImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetArtistImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetArtistImageRequest) Width(width int32) ImageAPIGetArtistImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetArtistImageRequest) Height(height int32) ImageAPIGetArtistImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetArtistImageRequest) Quality(quality int32) ImageAPIGetArtistImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetArtistImageRequest) FillWidth(fillWidth int32) ImageAPIGetArtistImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetArtistImageRequest) FillHeight(fillHeight int32) ImageAPIGetArtistImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetArtistImageRequest) Blur(blur int32) ImageAPIGetArtistImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetArtistImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetArtistImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetArtistImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetArtistImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetArtistImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetArtistImageExecute(r)
}

/*
GetArtistImage Get artist image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Artist name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIGetArtistImageRequest
*/
func (a *ImageAPIService) GetArtistImage(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIGetArtistImageRequest {
	return ImageAPIGetArtistImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetArtistImageExecute(r ImageAPIGetArtistImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetArtistImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetGenreImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetGenreImageRequest) Tag(tag string) ImageAPIGetGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetGenreImageRequest) Format(format JellyfinImageFormat) ImageAPIGetGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetGenreImageRequest) MaxWidth(maxWidth int32) ImageAPIGetGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetGenreImageRequest) MaxHeight(maxHeight int32) ImageAPIGetGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetGenreImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetGenreImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetGenreImageRequest) Width(width int32) ImageAPIGetGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetGenreImageRequest) Height(height int32) ImageAPIGetGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetGenreImageRequest) Quality(quality int32) ImageAPIGetGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetGenreImageRequest) FillWidth(fillWidth int32) ImageAPIGetGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetGenreImageRequest) FillHeight(fillHeight int32) ImageAPIGetGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetGenreImageRequest) Blur(blur int32) ImageAPIGetGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetGenreImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetGenreImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIGetGenreImageRequest) ImageIndex(imageIndex int32) ImageAPIGetGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIGetGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetGenreImageExecute(r)
}

/*
GetGenreImage Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @return ImageAPIGetGenreImageRequest
*/
func (a *ImageAPIService) GetGenreImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIGetGenreImageRequest {
	return ImageAPIGetGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetGenreImageExecute(r ImageAPIGetGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetGenreImageByIndexRequest) Tag(tag string) ImageAPIGetGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetGenreImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIGetGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetGenreImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIGetGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetGenreImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIGetGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIGetGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIGetGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetGenreImageByIndexRequest) Width(width int32) ImageAPIGetGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetGenreImageByIndexRequest) Height(height int32) ImageAPIGetGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetGenreImageByIndexRequest) Quality(quality int32) ImageAPIGetGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetGenreImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIGetGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetGenreImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIGetGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetGenreImageByIndexRequest) Blur(blur int32) ImageAPIGetGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIGetGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetGenreImageByIndexExecute(r)
}

/*
GetGenreImageByIndex Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIGetGenreImageByIndexRequest
*/
func (a *ImageAPIService) GetGenreImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIGetGenreImageByIndexRequest {
	return ImageAPIGetGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetGenreImageByIndexExecute(r ImageAPIGetGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetItemImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *JellyfinImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// The maximum image width to return.
func (r ImageAPIGetItemImageRequest) MaxWidth(maxWidth int32) ImageAPIGetItemImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetItemImageRequest) MaxHeight(maxHeight int32) ImageAPIGetItemImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageAPIGetItemImageRequest) Width(width int32) ImageAPIGetItemImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetItemImageRequest) Height(height int32) ImageAPIGetItemImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetItemImageRequest) Quality(quality int32) ImageAPIGetItemImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetItemImageRequest) FillWidth(fillWidth int32) ImageAPIGetItemImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetItemImageRequest) FillHeight(fillHeight int32) ImageAPIGetItemImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetItemImageRequest) Tag(tag string) ImageAPIGetItemImageRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ImageAPIGetItemImageRequest) Format(format JellyfinImageFormat) ImageAPIGetItemImageRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetItemImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetItemImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetItemImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetItemImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ImageAPIGetItemImageRequest) Blur(blur int32) ImageAPIGetItemImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetItemImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetItemImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetItemImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetItemImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIGetItemImageRequest) ImageIndex(imageIndex int32) ImageAPIGetItemImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIGetItemImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetItemImageExecute(r)
}

/*
GetItemImage Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ImageAPIGetItemImageRequest
*/
func (a *ImageAPIService) GetItemImage(ctx context.Context, itemId string, imageType JellyfinImageType) ImageAPIGetItemImageRequest {
	return ImageAPIGetItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetItemImageExecute(r ImageAPIGetItemImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetItemImage2Request struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	maxWidth int32
	maxHeight int32
	tag string
	format JellyfinImageFormat
	percentPlayed float64
	unplayedCount int32
	imageIndex int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The fixed image width to return.
func (r ImageAPIGetItemImage2Request) Width(width int32) ImageAPIGetItemImage2Request {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetItemImage2Request) Height(height int32) ImageAPIGetItemImage2Request {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetItemImage2Request) Quality(quality int32) ImageAPIGetItemImage2Request {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetItemImage2Request) FillWidth(fillWidth int32) ImageAPIGetItemImage2Request {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetItemImage2Request) FillHeight(fillHeight int32) ImageAPIGetItemImage2Request {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetItemImage2Request) Blur(blur int32) ImageAPIGetItemImage2Request {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetItemImage2Request) BackgroundColor(backgroundColor string) ImageAPIGetItemImage2Request {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetItemImage2Request) ForegroundLayer(foregroundLayer string) ImageAPIGetItemImage2Request {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetItemImage2Request) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetItemImage2Execute(r)
}

/*
GetItemImage2 Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param maxWidth The maximum image width to return.
 @param maxHeight The maximum image height to return.
 @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 @param format Determines the output format of the image - original,gif,jpg,png.
 @param percentPlayed Optional. Percent to render for the percent played overlay.
 @param unplayedCount Optional. Unplayed count overlay to render.
 @param imageIndex Image index.
 @return ImageAPIGetItemImage2Request
*/
func (a *ImageAPIService) GetItemImage2(ctx context.Context, itemId string, imageType JellyfinImageType, maxWidth int32, maxHeight int32, tag string, format JellyfinImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32) ImageAPIGetItemImage2Request {
	return ImageAPIGetItemImage2Request{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		maxWidth: maxWidth,
		maxHeight: maxHeight,
		tag: tag,
		format: format,
		percentPlayed: percentPlayed,
		unplayedCount: unplayedCount,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetItemImage2Execute(r ImageAPIGetItemImage2Request) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImage2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxWidth"+"}", url.PathEscape(parameterValueToString(r.maxWidth, "maxWidth")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxHeight"+"}", url.PathEscape(parameterValueToString(r.maxHeight, "maxHeight")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", url.PathEscape(parameterValueToString(r.tag, "tag")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"percentPlayed"+"}", url.PathEscape(parameterValueToString(r.percentPlayed, "percentPlayed")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unplayedCount"+"}", url.PathEscape(parameterValueToString(r.unplayedCount, "unplayedCount")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetItemImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	imageIndex int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *JellyfinImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The maximum image width to return.
func (r ImageAPIGetItemImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIGetItemImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetItemImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIGetItemImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageAPIGetItemImageByIndexRequest) Width(width int32) ImageAPIGetItemImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetItemImageByIndexRequest) Height(height int32) ImageAPIGetItemImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetItemImageByIndexRequest) Quality(quality int32) ImageAPIGetItemImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetItemImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIGetItemImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetItemImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIGetItemImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetItemImageByIndexRequest) Tag(tag string) ImageAPIGetItemImageByIndexRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ImageAPIGetItemImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIGetItemImageByIndexRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetItemImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIGetItemImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetItemImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIGetItemImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ImageAPIGetItemImageByIndexRequest) Blur(blur int32) ImageAPIGetItemImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetItemImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIGetItemImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetItemImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetItemImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetItemImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetItemImageByIndexExecute(r)
}

/*
GetItemImageByIndex Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIGetItemImageByIndexRequest
*/
func (a *ImageAPIService) GetItemImageByIndex(ctx context.Context, itemId string, imageType JellyfinImageType, imageIndex int32) ImageAPIGetItemImageByIndexRequest {
	return ImageAPIGetItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetItemImageByIndexExecute(r ImageAPIGetItemImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetItemImageInfosRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
}

func (r ImageAPIGetItemImageInfosRequest) Execute() ([]JellyfinImageInfo, *http.Response, error) {
	return r.ApiService.GetItemImageInfosExecute(r)
}

/*
GetItemImageInfos Get item image infos.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @return ImageAPIGetItemImageInfosRequest
*/
func (a *ImageAPIService) GetItemImageInfos(ctx context.Context, itemId string) ImageAPIGetItemImageInfosRequest {
	return ImageAPIGetItemImageInfosRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return []JellyfinImageInfo
func (a *ImageAPIService) GetItemImageInfosExecute(r ImageAPIGetItemImageInfosRequest) ([]JellyfinImageInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinImageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImageInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetMusicGenreImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetMusicGenreImageRequest) Tag(tag string) ImageAPIGetMusicGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetMusicGenreImageRequest) Format(format JellyfinImageFormat) ImageAPIGetMusicGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetMusicGenreImageRequest) MaxWidth(maxWidth int32) ImageAPIGetMusicGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetMusicGenreImageRequest) MaxHeight(maxHeight int32) ImageAPIGetMusicGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetMusicGenreImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetMusicGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetMusicGenreImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetMusicGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetMusicGenreImageRequest) Width(width int32) ImageAPIGetMusicGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetMusicGenreImageRequest) Height(height int32) ImageAPIGetMusicGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetMusicGenreImageRequest) Quality(quality int32) ImageAPIGetMusicGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetMusicGenreImageRequest) FillWidth(fillWidth int32) ImageAPIGetMusicGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetMusicGenreImageRequest) FillHeight(fillHeight int32) ImageAPIGetMusicGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetMusicGenreImageRequest) Blur(blur int32) ImageAPIGetMusicGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetMusicGenreImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetMusicGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetMusicGenreImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetMusicGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIGetMusicGenreImageRequest) ImageIndex(imageIndex int32) ImageAPIGetMusicGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIGetMusicGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMusicGenreImageExecute(r)
}

/*
GetMusicGenreImage Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @return ImageAPIGetMusicGenreImageRequest
*/
func (a *ImageAPIService) GetMusicGenreImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIGetMusicGenreImageRequest {
	return ImageAPIGetMusicGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetMusicGenreImageExecute(r ImageAPIGetMusicGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetMusicGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetMusicGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetMusicGenreImageByIndexRequest) Tag(tag string) ImageAPIGetMusicGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetMusicGenreImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIGetMusicGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetMusicGenreImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetMusicGenreImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetMusicGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIGetMusicGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetMusicGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetMusicGenreImageByIndexRequest) Width(width int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetMusicGenreImageByIndexRequest) Height(height int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetMusicGenreImageByIndexRequest) Quality(quality int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetMusicGenreImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetMusicGenreImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetMusicGenreImageByIndexRequest) Blur(blur int32) ImageAPIGetMusicGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetMusicGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIGetMusicGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetMusicGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetMusicGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetMusicGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMusicGenreImageByIndexExecute(r)
}

/*
GetMusicGenreImageByIndex Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIGetMusicGenreImageByIndexRequest
*/
func (a *ImageAPIService) GetMusicGenreImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIGetMusicGenreImageByIndexRequest {
	return ImageAPIGetMusicGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetMusicGenreImageByIndexExecute(r ImageAPIGetMusicGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetMusicGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetPersonImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetPersonImageRequest) Tag(tag string) ImageAPIGetPersonImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetPersonImageRequest) Format(format JellyfinImageFormat) ImageAPIGetPersonImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetPersonImageRequest) MaxWidth(maxWidth int32) ImageAPIGetPersonImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetPersonImageRequest) MaxHeight(maxHeight int32) ImageAPIGetPersonImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetPersonImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetPersonImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetPersonImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetPersonImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetPersonImageRequest) Width(width int32) ImageAPIGetPersonImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetPersonImageRequest) Height(height int32) ImageAPIGetPersonImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetPersonImageRequest) Quality(quality int32) ImageAPIGetPersonImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetPersonImageRequest) FillWidth(fillWidth int32) ImageAPIGetPersonImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetPersonImageRequest) FillHeight(fillHeight int32) ImageAPIGetPersonImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetPersonImageRequest) Blur(blur int32) ImageAPIGetPersonImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetPersonImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetPersonImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetPersonImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetPersonImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIGetPersonImageRequest) ImageIndex(imageIndex int32) ImageAPIGetPersonImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIGetPersonImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPersonImageExecute(r)
}

/*
GetPersonImage Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @return ImageAPIGetPersonImageRequest
*/
func (a *ImageAPIService) GetPersonImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIGetPersonImageRequest {
	return ImageAPIGetPersonImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetPersonImageExecute(r ImageAPIGetPersonImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetPersonImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetPersonImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetPersonImageByIndexRequest) Tag(tag string) ImageAPIGetPersonImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetPersonImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIGetPersonImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetPersonImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIGetPersonImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetPersonImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIGetPersonImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetPersonImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIGetPersonImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetPersonImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIGetPersonImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetPersonImageByIndexRequest) Width(width int32) ImageAPIGetPersonImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetPersonImageByIndexRequest) Height(height int32) ImageAPIGetPersonImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetPersonImageByIndexRequest) Quality(quality int32) ImageAPIGetPersonImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetPersonImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIGetPersonImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetPersonImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIGetPersonImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetPersonImageByIndexRequest) Blur(blur int32) ImageAPIGetPersonImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetPersonImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIGetPersonImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetPersonImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetPersonImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetPersonImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPersonImageByIndexExecute(r)
}

/*
GetPersonImageByIndex Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIGetPersonImageByIndexRequest
*/
func (a *ImageAPIService) GetPersonImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIGetPersonImageByIndexRequest {
	return ImageAPIGetPersonImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetPersonImageByIndexExecute(r ImageAPIGetPersonImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetPersonImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetSplashscreenRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	quality *int32
}

// Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetSplashscreenRequest) Tag(tag string) ImageAPIGetSplashscreenRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetSplashscreenRequest) Format(format JellyfinImageFormat) ImageAPIGetSplashscreenRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetSplashscreenRequest) MaxWidth(maxWidth int32) ImageAPIGetSplashscreenRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetSplashscreenRequest) MaxHeight(maxHeight int32) ImageAPIGetSplashscreenRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageAPIGetSplashscreenRequest) Width(width int32) ImageAPIGetSplashscreenRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetSplashscreenRequest) Height(height int32) ImageAPIGetSplashscreenRequest {
	r.height = &height
	return r
}

// Width of box to fill.
func (r ImageAPIGetSplashscreenRequest) FillWidth(fillWidth int32) ImageAPIGetSplashscreenRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetSplashscreenRequest) FillHeight(fillHeight int32) ImageAPIGetSplashscreenRequest {
	r.fillHeight = &fillHeight
	return r
}

// Blur image.
func (r ImageAPIGetSplashscreenRequest) Blur(blur int32) ImageAPIGetSplashscreenRequest {
	r.blur = &blur
	return r
}

// Apply a background color for transparent images.
func (r ImageAPIGetSplashscreenRequest) BackgroundColor(backgroundColor string) ImageAPIGetSplashscreenRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Apply a foreground layer on top of the image.
func (r ImageAPIGetSplashscreenRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetSplashscreenRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Quality setting, from 0-100.
func (r ImageAPIGetSplashscreenRequest) Quality(quality int32) ImageAPIGetSplashscreenRequest {
	r.quality = &quality
	return r
}

func (r ImageAPIGetSplashscreenRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetSplashscreenExecute(r)
}

/*
GetSplashscreen Generates or gets the splashscreen.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIGetSplashscreenRequest
*/
func (a *ImageAPIService) GetSplashscreen(ctx context.Context) ImageAPIGetSplashscreenRequest {
	return ImageAPIGetSplashscreenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetSplashscreenExecute(r ImageAPIGetSplashscreenRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetSplashscreen")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Branding/Splashscreen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	} else {
		var defaultValue int32 = 90
		r.quality = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetStudioImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetStudioImageRequest) Tag(tag string) ImageAPIGetStudioImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetStudioImageRequest) Format(format JellyfinImageFormat) ImageAPIGetStudioImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetStudioImageRequest) MaxWidth(maxWidth int32) ImageAPIGetStudioImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetStudioImageRequest) MaxHeight(maxHeight int32) ImageAPIGetStudioImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetStudioImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetStudioImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetStudioImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetStudioImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetStudioImageRequest) Width(width int32) ImageAPIGetStudioImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetStudioImageRequest) Height(height int32) ImageAPIGetStudioImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetStudioImageRequest) Quality(quality int32) ImageAPIGetStudioImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetStudioImageRequest) FillWidth(fillWidth int32) ImageAPIGetStudioImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetStudioImageRequest) FillHeight(fillHeight int32) ImageAPIGetStudioImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetStudioImageRequest) Blur(blur int32) ImageAPIGetStudioImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetStudioImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetStudioImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetStudioImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetStudioImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIGetStudioImageRequest) ImageIndex(imageIndex int32) ImageAPIGetStudioImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIGetStudioImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetStudioImageExecute(r)
}

/*
GetStudioImage Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @return ImageAPIGetStudioImageRequest
*/
func (a *ImageAPIService) GetStudioImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIGetStudioImageRequest {
	return ImageAPIGetStudioImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetStudioImageExecute(r ImageAPIGetStudioImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetStudioImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetStudioImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetStudioImageByIndexRequest) Tag(tag string) ImageAPIGetStudioImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetStudioImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIGetStudioImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetStudioImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIGetStudioImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetStudioImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIGetStudioImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetStudioImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIGetStudioImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetStudioImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIGetStudioImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetStudioImageByIndexRequest) Width(width int32) ImageAPIGetStudioImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetStudioImageByIndexRequest) Height(height int32) ImageAPIGetStudioImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetStudioImageByIndexRequest) Quality(quality int32) ImageAPIGetStudioImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetStudioImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIGetStudioImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetStudioImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIGetStudioImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetStudioImageByIndexRequest) Blur(blur int32) ImageAPIGetStudioImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetStudioImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIGetStudioImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetStudioImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetStudioImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIGetStudioImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetStudioImageByIndexExecute(r)
}

/*
GetStudioImageByIndex Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIGetStudioImageByIndexRequest
*/
func (a *ImageAPIService) GetStudioImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIGetStudioImageByIndexRequest {
	return ImageAPIGetStudioImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetStudioImageByIndexExecute(r ImageAPIGetStudioImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetStudioImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIGetUserImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	userId *string
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// User id.
func (r ImageAPIGetUserImageRequest) UserId(userId string) ImageAPIGetUserImageRequest {
	r.userId = &userId
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIGetUserImageRequest) Tag(tag string) ImageAPIGetUserImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIGetUserImageRequest) Format(format JellyfinImageFormat) ImageAPIGetUserImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIGetUserImageRequest) MaxWidth(maxWidth int32) ImageAPIGetUserImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIGetUserImageRequest) MaxHeight(maxHeight int32) ImageAPIGetUserImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIGetUserImageRequest) PercentPlayed(percentPlayed float64) ImageAPIGetUserImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIGetUserImageRequest) UnplayedCount(unplayedCount int32) ImageAPIGetUserImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIGetUserImageRequest) Width(width int32) ImageAPIGetUserImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIGetUserImageRequest) Height(height int32) ImageAPIGetUserImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIGetUserImageRequest) Quality(quality int32) ImageAPIGetUserImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIGetUserImageRequest) FillWidth(fillWidth int32) ImageAPIGetUserImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIGetUserImageRequest) FillHeight(fillHeight int32) ImageAPIGetUserImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIGetUserImageRequest) Blur(blur int32) ImageAPIGetUserImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIGetUserImageRequest) BackgroundColor(backgroundColor string) ImageAPIGetUserImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIGetUserImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIGetUserImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIGetUserImageRequest) ImageIndex(imageIndex int32) ImageAPIGetUserImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIGetUserImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetUserImageExecute(r)
}

/*
GetUserImage Get user profile image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIGetUserImageRequest
*/
func (a *ImageAPIService) GetUserImage(ctx context.Context) ImageAPIGetUserImageRequest {
	return ImageAPIGetUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetUserImageExecute(r ImageAPIGetUserImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetUserImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadArtistImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadArtistImageRequest) Tag(tag string) ImageAPIHeadArtistImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadArtistImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadArtistImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadArtistImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadArtistImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadArtistImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadArtistImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadArtistImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadArtistImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadArtistImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadArtistImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadArtistImageRequest) Width(width int32) ImageAPIHeadArtistImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadArtistImageRequest) Height(height int32) ImageAPIHeadArtistImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadArtistImageRequest) Quality(quality int32) ImageAPIHeadArtistImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadArtistImageRequest) FillWidth(fillWidth int32) ImageAPIHeadArtistImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadArtistImageRequest) FillHeight(fillHeight int32) ImageAPIHeadArtistImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadArtistImageRequest) Blur(blur int32) ImageAPIHeadArtistImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadArtistImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadArtistImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadArtistImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadArtistImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadArtistImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadArtistImageExecute(r)
}

/*
HeadArtistImage Get artist image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Artist name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIHeadArtistImageRequest
*/
func (a *ImageAPIService) HeadArtistImage(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIHeadArtistImageRequest {
	return ImageAPIHeadArtistImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadArtistImageExecute(r ImageAPIHeadArtistImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadArtistImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadGenreImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadGenreImageRequest) Tag(tag string) ImageAPIHeadGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadGenreImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadGenreImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadGenreImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadGenreImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadGenreImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadGenreImageRequest) Width(width int32) ImageAPIHeadGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadGenreImageRequest) Height(height int32) ImageAPIHeadGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadGenreImageRequest) Quality(quality int32) ImageAPIHeadGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadGenreImageRequest) FillWidth(fillWidth int32) ImageAPIHeadGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadGenreImageRequest) FillHeight(fillHeight int32) ImageAPIHeadGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadGenreImageRequest) Blur(blur int32) ImageAPIHeadGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadGenreImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadGenreImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIHeadGenreImageRequest) ImageIndex(imageIndex int32) ImageAPIHeadGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIHeadGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadGenreImageExecute(r)
}

/*
HeadGenreImage Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @return ImageAPIHeadGenreImageRequest
*/
func (a *ImageAPIService) HeadGenreImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIHeadGenreImageRequest {
	return ImageAPIHeadGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadGenreImageExecute(r ImageAPIHeadGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadGenreImageByIndexRequest) Tag(tag string) ImageAPIHeadGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadGenreImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIHeadGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadGenreImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIHeadGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadGenreImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIHeadGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadGenreImageByIndexRequest) Width(width int32) ImageAPIHeadGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadGenreImageByIndexRequest) Height(height int32) ImageAPIHeadGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadGenreImageByIndexRequest) Quality(quality int32) ImageAPIHeadGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadGenreImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIHeadGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadGenreImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIHeadGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadGenreImageByIndexRequest) Blur(blur int32) ImageAPIHeadGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIHeadGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadGenreImageByIndexExecute(r)
}

/*
HeadGenreImageByIndex Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIHeadGenreImageByIndexRequest
*/
func (a *ImageAPIService) HeadGenreImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIHeadGenreImageByIndexRequest {
	return ImageAPIHeadGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadGenreImageByIndexExecute(r ImageAPIHeadGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadItemImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *JellyfinImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// The maximum image width to return.
func (r ImageAPIHeadItemImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadItemImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadItemImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadItemImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadItemImageRequest) Width(width int32) ImageAPIHeadItemImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadItemImageRequest) Height(height int32) ImageAPIHeadItemImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadItemImageRequest) Quality(quality int32) ImageAPIHeadItemImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadItemImageRequest) FillWidth(fillWidth int32) ImageAPIHeadItemImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadItemImageRequest) FillHeight(fillHeight int32) ImageAPIHeadItemImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadItemImageRequest) Tag(tag string) ImageAPIHeadItemImageRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ImageAPIHeadItemImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadItemImageRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadItemImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadItemImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadItemImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadItemImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadItemImageRequest) Blur(blur int32) ImageAPIHeadItemImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadItemImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadItemImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadItemImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadItemImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIHeadItemImageRequest) ImageIndex(imageIndex int32) ImageAPIHeadItemImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIHeadItemImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadItemImageExecute(r)
}

/*
HeadItemImage Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ImageAPIHeadItemImageRequest
*/
func (a *ImageAPIService) HeadItemImage(ctx context.Context, itemId string, imageType JellyfinImageType) ImageAPIHeadItemImageRequest {
	return ImageAPIHeadItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadItemImageExecute(r ImageAPIHeadItemImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadItemImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadItemImage2Request struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	maxWidth int32
	maxHeight int32
	tag string
	format JellyfinImageFormat
	percentPlayed float64
	unplayedCount int32
	imageIndex int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The fixed image width to return.
func (r ImageAPIHeadItemImage2Request) Width(width int32) ImageAPIHeadItemImage2Request {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadItemImage2Request) Height(height int32) ImageAPIHeadItemImage2Request {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadItemImage2Request) Quality(quality int32) ImageAPIHeadItemImage2Request {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadItemImage2Request) FillWidth(fillWidth int32) ImageAPIHeadItemImage2Request {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadItemImage2Request) FillHeight(fillHeight int32) ImageAPIHeadItemImage2Request {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadItemImage2Request) Blur(blur int32) ImageAPIHeadItemImage2Request {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadItemImage2Request) BackgroundColor(backgroundColor string) ImageAPIHeadItemImage2Request {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadItemImage2Request) ForegroundLayer(foregroundLayer string) ImageAPIHeadItemImage2Request {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadItemImage2Request) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadItemImage2Execute(r)
}

/*
HeadItemImage2 Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param maxWidth The maximum image width to return.
 @param maxHeight The maximum image height to return.
 @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 @param format Determines the output format of the image - original,gif,jpg,png.
 @param percentPlayed Optional. Percent to render for the percent played overlay.
 @param unplayedCount Optional. Unplayed count overlay to render.
 @param imageIndex Image index.
 @return ImageAPIHeadItemImage2Request
*/
func (a *ImageAPIService) HeadItemImage2(ctx context.Context, itemId string, imageType JellyfinImageType, maxWidth int32, maxHeight int32, tag string, format JellyfinImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32) ImageAPIHeadItemImage2Request {
	return ImageAPIHeadItemImage2Request{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		maxWidth: maxWidth,
		maxHeight: maxHeight,
		tag: tag,
		format: format,
		percentPlayed: percentPlayed,
		unplayedCount: unplayedCount,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadItemImage2Execute(r ImageAPIHeadItemImage2Request) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadItemImage2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxWidth"+"}", url.PathEscape(parameterValueToString(r.maxWidth, "maxWidth")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxHeight"+"}", url.PathEscape(parameterValueToString(r.maxHeight, "maxHeight")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", url.PathEscape(parameterValueToString(r.tag, "tag")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"percentPlayed"+"}", url.PathEscape(parameterValueToString(r.percentPlayed, "percentPlayed")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unplayedCount"+"}", url.PathEscape(parameterValueToString(r.unplayedCount, "unplayedCount")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadItemImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	imageIndex int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *JellyfinImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The maximum image width to return.
func (r ImageAPIHeadItemImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIHeadItemImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadItemImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIHeadItemImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadItemImageByIndexRequest) Width(width int32) ImageAPIHeadItemImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadItemImageByIndexRequest) Height(height int32) ImageAPIHeadItemImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadItemImageByIndexRequest) Quality(quality int32) ImageAPIHeadItemImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadItemImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIHeadItemImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadItemImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIHeadItemImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadItemImageByIndexRequest) Tag(tag string) ImageAPIHeadItemImageByIndexRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ImageAPIHeadItemImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIHeadItemImageByIndexRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadItemImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadItemImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadItemImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadItemImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadItemImageByIndexRequest) Blur(blur int32) ImageAPIHeadItemImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadItemImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIHeadItemImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadItemImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadItemImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadItemImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadItemImageByIndexExecute(r)
}

/*
HeadItemImageByIndex Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIHeadItemImageByIndexRequest
*/
func (a *ImageAPIService) HeadItemImageByIndex(ctx context.Context, itemId string, imageType JellyfinImageType, imageIndex int32) ImageAPIHeadItemImageByIndexRequest {
	return ImageAPIHeadItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadItemImageByIndexExecute(r ImageAPIHeadItemImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadItemImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadMusicGenreImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadMusicGenreImageRequest) Tag(tag string) ImageAPIHeadMusicGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadMusicGenreImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadMusicGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadMusicGenreImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadMusicGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadMusicGenreImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadMusicGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadMusicGenreImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadMusicGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadMusicGenreImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadMusicGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadMusicGenreImageRequest) Width(width int32) ImageAPIHeadMusicGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadMusicGenreImageRequest) Height(height int32) ImageAPIHeadMusicGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadMusicGenreImageRequest) Quality(quality int32) ImageAPIHeadMusicGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadMusicGenreImageRequest) FillWidth(fillWidth int32) ImageAPIHeadMusicGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadMusicGenreImageRequest) FillHeight(fillHeight int32) ImageAPIHeadMusicGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadMusicGenreImageRequest) Blur(blur int32) ImageAPIHeadMusicGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadMusicGenreImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadMusicGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadMusicGenreImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadMusicGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIHeadMusicGenreImageRequest) ImageIndex(imageIndex int32) ImageAPIHeadMusicGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIHeadMusicGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMusicGenreImageExecute(r)
}

/*
HeadMusicGenreImage Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @return ImageAPIHeadMusicGenreImageRequest
*/
func (a *ImageAPIService) HeadMusicGenreImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIHeadMusicGenreImageRequest {
	return ImageAPIHeadMusicGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadMusicGenreImageExecute(r ImageAPIHeadMusicGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadMusicGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadMusicGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) Tag(tag string) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) Width(width int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) Height(height int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) Quality(quality int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) Blur(blur int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadMusicGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadMusicGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadMusicGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMusicGenreImageByIndexExecute(r)
}

/*
HeadMusicGenreImageByIndex Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIHeadMusicGenreImageByIndexRequest
*/
func (a *ImageAPIService) HeadMusicGenreImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIHeadMusicGenreImageByIndexRequest {
	return ImageAPIHeadMusicGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadMusicGenreImageByIndexExecute(r ImageAPIHeadMusicGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadMusicGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadPersonImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadPersonImageRequest) Tag(tag string) ImageAPIHeadPersonImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadPersonImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadPersonImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadPersonImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadPersonImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadPersonImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadPersonImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadPersonImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadPersonImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadPersonImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadPersonImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadPersonImageRequest) Width(width int32) ImageAPIHeadPersonImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadPersonImageRequest) Height(height int32) ImageAPIHeadPersonImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadPersonImageRequest) Quality(quality int32) ImageAPIHeadPersonImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadPersonImageRequest) FillWidth(fillWidth int32) ImageAPIHeadPersonImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadPersonImageRequest) FillHeight(fillHeight int32) ImageAPIHeadPersonImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadPersonImageRequest) Blur(blur int32) ImageAPIHeadPersonImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadPersonImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadPersonImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadPersonImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadPersonImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIHeadPersonImageRequest) ImageIndex(imageIndex int32) ImageAPIHeadPersonImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIHeadPersonImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadPersonImageExecute(r)
}

/*
HeadPersonImage Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @return ImageAPIHeadPersonImageRequest
*/
func (a *ImageAPIService) HeadPersonImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIHeadPersonImageRequest {
	return ImageAPIHeadPersonImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadPersonImageExecute(r ImageAPIHeadPersonImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadPersonImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadPersonImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadPersonImageByIndexRequest) Tag(tag string) ImageAPIHeadPersonImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadPersonImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIHeadPersonImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadPersonImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIHeadPersonImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadPersonImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIHeadPersonImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadPersonImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadPersonImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadPersonImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadPersonImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadPersonImageByIndexRequest) Width(width int32) ImageAPIHeadPersonImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadPersonImageByIndexRequest) Height(height int32) ImageAPIHeadPersonImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadPersonImageByIndexRequest) Quality(quality int32) ImageAPIHeadPersonImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadPersonImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIHeadPersonImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadPersonImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIHeadPersonImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadPersonImageByIndexRequest) Blur(blur int32) ImageAPIHeadPersonImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadPersonImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIHeadPersonImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadPersonImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadPersonImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadPersonImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadPersonImageByIndexExecute(r)
}

/*
HeadPersonImageByIndex Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIHeadPersonImageByIndexRequest
*/
func (a *ImageAPIService) HeadPersonImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIHeadPersonImageByIndexRequest {
	return ImageAPIHeadPersonImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadPersonImageByIndexExecute(r ImageAPIHeadPersonImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadPersonImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadStudioImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadStudioImageRequest) Tag(tag string) ImageAPIHeadStudioImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadStudioImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadStudioImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadStudioImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadStudioImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadStudioImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadStudioImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadStudioImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadStudioImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadStudioImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadStudioImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadStudioImageRequest) Width(width int32) ImageAPIHeadStudioImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadStudioImageRequest) Height(height int32) ImageAPIHeadStudioImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadStudioImageRequest) Quality(quality int32) ImageAPIHeadStudioImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadStudioImageRequest) FillWidth(fillWidth int32) ImageAPIHeadStudioImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadStudioImageRequest) FillHeight(fillHeight int32) ImageAPIHeadStudioImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadStudioImageRequest) Blur(blur int32) ImageAPIHeadStudioImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadStudioImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadStudioImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadStudioImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadStudioImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIHeadStudioImageRequest) ImageIndex(imageIndex int32) ImageAPIHeadStudioImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIHeadStudioImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadStudioImageExecute(r)
}

/*
HeadStudioImage Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @return ImageAPIHeadStudioImageRequest
*/
func (a *ImageAPIService) HeadStudioImage(ctx context.Context, name string, imageType JellyfinImageType) ImageAPIHeadStudioImageRequest {
	return ImageAPIHeadStudioImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadStudioImageExecute(r ImageAPIHeadStudioImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadStudioImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadStudioImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	name string
	imageType JellyfinImageType
	imageIndex int32
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadStudioImageByIndexRequest) Tag(tag string) ImageAPIHeadStudioImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadStudioImageByIndexRequest) Format(format JellyfinImageFormat) ImageAPIHeadStudioImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadStudioImageByIndexRequest) MaxWidth(maxWidth int32) ImageAPIHeadStudioImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadStudioImageByIndexRequest) MaxHeight(maxHeight int32) ImageAPIHeadStudioImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadStudioImageByIndexRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadStudioImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadStudioImageByIndexRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadStudioImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadStudioImageByIndexRequest) Width(width int32) ImageAPIHeadStudioImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadStudioImageByIndexRequest) Height(height int32) ImageAPIHeadStudioImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadStudioImageByIndexRequest) Quality(quality int32) ImageAPIHeadStudioImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadStudioImageByIndexRequest) FillWidth(fillWidth int32) ImageAPIHeadStudioImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadStudioImageByIndexRequest) FillHeight(fillHeight int32) ImageAPIHeadStudioImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadStudioImageByIndexRequest) Blur(blur int32) ImageAPIHeadStudioImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadStudioImageByIndexRequest) BackgroundColor(backgroundColor string) ImageAPIHeadStudioImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadStudioImageByIndexRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadStudioImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ImageAPIHeadStudioImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadStudioImageByIndexExecute(r)
}

/*
HeadStudioImageByIndex Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ImageAPIHeadStudioImageByIndexRequest
*/
func (a *ImageAPIService) HeadStudioImageByIndex(ctx context.Context, name string, imageType JellyfinImageType, imageIndex int32) ImageAPIHeadStudioImageByIndexRequest {
	return ImageAPIHeadStudioImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadStudioImageByIndexExecute(r ImageAPIHeadStudioImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadStudioImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIHeadUserImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	userId *string
	tag *string
	format *JellyfinImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// User id.
func (r ImageAPIHeadUserImageRequest) UserId(userId string) ImageAPIHeadUserImageRequest {
	r.userId = &userId
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ImageAPIHeadUserImageRequest) Tag(tag string) ImageAPIHeadUserImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ImageAPIHeadUserImageRequest) Format(format JellyfinImageFormat) ImageAPIHeadUserImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ImageAPIHeadUserImageRequest) MaxWidth(maxWidth int32) ImageAPIHeadUserImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ImageAPIHeadUserImageRequest) MaxHeight(maxHeight int32) ImageAPIHeadUserImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ImageAPIHeadUserImageRequest) PercentPlayed(percentPlayed float64) ImageAPIHeadUserImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ImageAPIHeadUserImageRequest) UnplayedCount(unplayedCount int32) ImageAPIHeadUserImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ImageAPIHeadUserImageRequest) Width(width int32) ImageAPIHeadUserImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ImageAPIHeadUserImageRequest) Height(height int32) ImageAPIHeadUserImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ImageAPIHeadUserImageRequest) Quality(quality int32) ImageAPIHeadUserImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ImageAPIHeadUserImageRequest) FillWidth(fillWidth int32) ImageAPIHeadUserImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ImageAPIHeadUserImageRequest) FillHeight(fillHeight int32) ImageAPIHeadUserImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ImageAPIHeadUserImageRequest) Blur(blur int32) ImageAPIHeadUserImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ImageAPIHeadUserImageRequest) BackgroundColor(backgroundColor string) ImageAPIHeadUserImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ImageAPIHeadUserImageRequest) ForegroundLayer(foregroundLayer string) ImageAPIHeadUserImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ImageAPIHeadUserImageRequest) ImageIndex(imageIndex int32) ImageAPIHeadUserImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ImageAPIHeadUserImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadUserImageExecute(r)
}

/*
HeadUserImage Get user profile image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIHeadUserImageRequest
*/
func (a *ImageAPIService) HeadUserImage(ctx context.Context) ImageAPIHeadUserImageRequest {
	return ImageAPIHeadUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadUserImageExecute(r ImageAPIHeadUserImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadUserImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ImageAPIPostUserImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	userId *string
	body *os.File
}

// User Id.
func (r ImageAPIPostUserImageRequest) UserId(userId string) ImageAPIPostUserImageRequest {
	r.userId = &userId
	return r
}

func (r ImageAPIPostUserImageRequest) Body(body *os.File) ImageAPIPostUserImageRequest {
	r.body = body
	return r
}

func (r ImageAPIPostUserImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUserImageExecute(r)
}

/*
PostUserImage Sets the user image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIPostUserImageRequest
*/
func (a *ImageAPIService) PostUserImage(ctx context.Context) ImageAPIPostUserImageRequest {
	return ImageAPIPostUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) PostUserImageExecute(r ImageAPIPostUserImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.PostUserImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPISetItemImageRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	body *os.File
}

func (r ImageAPISetItemImageRequest) Body(body *os.File) ImageAPISetItemImageRequest {
	r.body = body
	return r
}

func (r ImageAPISetItemImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetItemImageExecute(r)
}

/*
SetItemImage Set item image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ImageAPISetItemImageRequest
*/
func (a *ImageAPIService) SetItemImage(ctx context.Context, itemId string, imageType JellyfinImageType) ImageAPISetItemImageRequest {
	return ImageAPISetItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
func (a *ImageAPIService) SetItemImageExecute(r ImageAPISetItemImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.SetItemImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPISetItemImageByIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	imageIndex int32
	body *os.File
}

func (r ImageAPISetItemImageByIndexRequest) Body(body *os.File) ImageAPISetItemImageByIndexRequest {
	r.body = body
	return r
}

func (r ImageAPISetItemImageByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetItemImageByIndexExecute(r)
}

/*
SetItemImageByIndex Set item image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex (Unused) Image index.
 @return ImageAPISetItemImageByIndexRequest
*/
func (a *ImageAPIService) SetItemImageByIndex(ctx context.Context, itemId string, imageType JellyfinImageType, imageIndex int32) ImageAPISetItemImageByIndexRequest {
	return ImageAPISetItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
func (a *ImageAPIService) SetItemImageByIndexExecute(r ImageAPISetItemImageByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.SetItemImageByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPIUpdateItemImageIndexRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	itemId string
	imageType JellyfinImageType
	imageIndex int32
	newIndex *int32
}

// New image index.
func (r ImageAPIUpdateItemImageIndexRequest) NewIndex(newIndex int32) ImageAPIUpdateItemImageIndexRequest {
	r.newIndex = &newIndex
	return r
}

func (r ImageAPIUpdateItemImageIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateItemImageIndexExecute(r)
}

/*
UpdateItemImageIndex Updates the index for an item image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex Old image index.
 @return ImageAPIUpdateItemImageIndexRequest
*/
func (a *ImageAPIService) UpdateItemImageIndex(ctx context.Context, itemId string, imageType JellyfinImageType, imageIndex int32) ImageAPIUpdateItemImageIndexRequest {
	return ImageAPIUpdateItemImageIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
func (a *ImageAPIService) UpdateItemImageIndexExecute(r ImageAPIUpdateItemImageIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.UpdateItemImageIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/Index"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newIndex == nil {
		return nil, reportError("newIndex is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "newIndex", r.newIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ImageAPIUploadCustomSplashscreenRequest struct {
	ctx context.Context
	ApiService *ImageAPIService
	body *os.File
}

func (r ImageAPIUploadCustomSplashscreenRequest) Body(body *os.File) ImageAPIUploadCustomSplashscreenRequest {
	r.body = body
	return r
}

func (r ImageAPIUploadCustomSplashscreenRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadCustomSplashscreenExecute(r)
}

/*
UploadCustomSplashscreen Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ImageAPIUploadCustomSplashscreenRequest
*/
func (a *ImageAPIService) UploadCustomSplashscreen(ctx context.Context) ImageAPIUploadCustomSplashscreenRequest {
	return ImageAPIUploadCustomSplashscreenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) UploadCustomSplashscreenExecute(r ImageAPIUploadCustomSplashscreenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.UploadCustomSplashscreen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Branding/Splashscreen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v JellyfinProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

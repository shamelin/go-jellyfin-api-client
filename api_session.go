/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jellyfin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SessionAPIService SessionAPI service
type SessionAPIService service

type SessionAPIAddUserToSessionRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	userId string
}

func (r SessionAPIAddUserToSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddUserToSessionExecute(r)
}

/*
AddUserToSession Adds an additional user to a session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param userId The user id.
 @return SessionAPIAddUserToSessionRequest
*/
func (a *SessionAPIService) AddUserToSession(ctx context.Context, sessionId string, userId string) SessionAPIAddUserToSessionRequest {
	return SessionAPIAddUserToSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionAPIService) AddUserToSessionExecute(r SessionAPIAddUserToSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.AddUserToSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/User/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIDisplayContentRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	itemType *JellyfinBaseItemKind
	itemId *string
	itemName *string
}

// The type of item to browse to.
func (r SessionAPIDisplayContentRequest) ItemType(itemType JellyfinBaseItemKind) SessionAPIDisplayContentRequest {
	r.itemType = &itemType
	return r
}

// The Id of the item.
func (r SessionAPIDisplayContentRequest) ItemId(itemId string) SessionAPIDisplayContentRequest {
	r.itemId = &itemId
	return r
}

// The name of the item.
func (r SessionAPIDisplayContentRequest) ItemName(itemName string) SessionAPIDisplayContentRequest {
	r.itemName = &itemName
	return r
}

func (r SessionAPIDisplayContentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisplayContentExecute(r)
}

/*
DisplayContent Instructs a session to browse to an item or view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session Id.
 @return SessionAPIDisplayContentRequest
*/
func (a *SessionAPIService) DisplayContent(ctx context.Context, sessionId string) SessionAPIDisplayContentRequest {
	return SessionAPIDisplayContentRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) DisplayContentExecute(r SessionAPIDisplayContentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.DisplayContent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Viewing"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemType == nil {
		return nil, reportError("itemType is required and must be specified")
	}
	if r.itemId == nil {
		return nil, reportError("itemId is required and must be specified")
	}
	if r.itemName == nil {
		return nil, reportError("itemName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "itemType", r.itemType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "itemId", r.itemId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "itemName", r.itemName, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIGetAuthProvidersRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
}

func (r SessionAPIGetAuthProvidersRequest) Execute() ([]JellyfinNameIdPair, *http.Response, error) {
	return r.ApiService.GetAuthProvidersExecute(r)
}

/*
GetAuthProviders Get all auth providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIGetAuthProvidersRequest
*/
func (a *SessionAPIService) GetAuthProviders(ctx context.Context) SessionAPIGetAuthProvidersRequest {
	return SessionAPIGetAuthProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinNameIdPair
func (a *SessionAPIService) GetAuthProvidersExecute(r SessionAPIGetAuthProvidersRequest) ([]JellyfinNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.GetAuthProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionAPIGetPasswordResetProvidersRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
}

func (r SessionAPIGetPasswordResetProvidersRequest) Execute() ([]JellyfinNameIdPair, *http.Response, error) {
	return r.ApiService.GetPasswordResetProvidersExecute(r)
}

/*
GetPasswordResetProviders Get all password reset providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIGetPasswordResetProvidersRequest
*/
func (a *SessionAPIService) GetPasswordResetProviders(ctx context.Context) SessionAPIGetPasswordResetProvidersRequest {
	return SessionAPIGetPasswordResetProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinNameIdPair
func (a *SessionAPIService) GetPasswordResetProvidersExecute(r SessionAPIGetPasswordResetProvidersRequest) ([]JellyfinNameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinNameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.GetPasswordResetProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/PasswordResetProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionAPIGetSessionsRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	controllableByUserId *string
	deviceId *string
	activeWithinSeconds *int32
}

// Filter by sessions that a given user is allowed to remote control.
func (r SessionAPIGetSessionsRequest) ControllableByUserId(controllableByUserId string) SessionAPIGetSessionsRequest {
	r.controllableByUserId = &controllableByUserId
	return r
}

// Filter by device Id.
func (r SessionAPIGetSessionsRequest) DeviceId(deviceId string) SessionAPIGetSessionsRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Filter by sessions that were active in the last n seconds.
func (r SessionAPIGetSessionsRequest) ActiveWithinSeconds(activeWithinSeconds int32) SessionAPIGetSessionsRequest {
	r.activeWithinSeconds = &activeWithinSeconds
	return r
}

func (r SessionAPIGetSessionsRequest) Execute() ([]JellyfinSessionInfoDto, *http.Response, error) {
	return r.ApiService.GetSessionsExecute(r)
}

/*
GetSessions Gets a list of sessions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIGetSessionsRequest
*/
func (a *SessionAPIService) GetSessions(ctx context.Context) SessionAPIGetSessionsRequest {
	return SessionAPIGetSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JellyfinSessionInfoDto
func (a *SessionAPIService) GetSessionsExecute(r SessionAPIGetSessionsRequest) ([]JellyfinSessionInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JellyfinSessionInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.GetSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.controllableByUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controllableByUserId", r.controllableByUserId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.activeWithinSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeWithinSeconds", r.activeWithinSeconds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SessionAPIPlayRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	playCommand *JellyfinPlayCommand
	itemIds *[]string
	startPositionTicks *int64
	mediaSourceId *string
	audioStreamIndex *int32
	subtitleStreamIndex *int32
	startIndex *int32
}

// The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
func (r SessionAPIPlayRequest) PlayCommand(playCommand JellyfinPlayCommand) SessionAPIPlayRequest {
	r.playCommand = &playCommand
	return r
}

// The ids of the items to play, comma delimited.
func (r SessionAPIPlayRequest) ItemIds(itemIds []string) SessionAPIPlayRequest {
	r.itemIds = &itemIds
	return r
}

// The starting position of the first item.
func (r SessionAPIPlayRequest) StartPositionTicks(startPositionTicks int64) SessionAPIPlayRequest {
	r.startPositionTicks = &startPositionTicks
	return r
}

// Optional. The media source id.
func (r SessionAPIPlayRequest) MediaSourceId(mediaSourceId string) SessionAPIPlayRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. The index of the audio stream to play.
func (r SessionAPIPlayRequest) AudioStreamIndex(audioStreamIndex int32) SessionAPIPlayRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the subtitle stream to play.
func (r SessionAPIPlayRequest) SubtitleStreamIndex(subtitleStreamIndex int32) SessionAPIPlayRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. The start index.
func (r SessionAPIPlayRequest) StartIndex(startIndex int32) SessionAPIPlayRequest {
	r.startIndex = &startIndex
	return r
}

func (r SessionAPIPlayRequest) Execute() (*http.Response, error) {
	return r.ApiService.PlayExecute(r)
}

/*
Play Instructs a session to play an item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @return SessionAPIPlayRequest
*/
func (a *SessionAPIService) Play(ctx context.Context, sessionId string) SessionAPIPlayRequest {
	return SessionAPIPlayRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) PlayExecute(r SessionAPIPlayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.Play")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Playing"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playCommand == nil {
		return nil, reportError("playCommand is required and must be specified")
	}
	if r.itemIds == nil {
		return nil, reportError("itemIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "playCommand", r.playCommand, "form", "")
	{
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", t, "form", "multi")
		}
	}
	if r.startPositionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startPositionTicks", r.startPositionTicks, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIPostCapabilitiesRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	id *string
	playableMediaTypes *[]JellyfinMediaType
	supportedCommands *[]JellyfinGeneralCommandType
	supportsMediaControl *bool
	supportsPersistentIdentifier *bool
}

// The session id.
func (r SessionAPIPostCapabilitiesRequest) Id(id string) SessionAPIPostCapabilitiesRequest {
	r.id = &id
	return r
}

// A list of playable media types, comma delimited. Audio, Video, Book, Photo.
func (r SessionAPIPostCapabilitiesRequest) PlayableMediaTypes(playableMediaTypes []JellyfinMediaType) SessionAPIPostCapabilitiesRequest {
	r.playableMediaTypes = &playableMediaTypes
	return r
}

// A list of supported remote control commands, comma delimited.
func (r SessionAPIPostCapabilitiesRequest) SupportedCommands(supportedCommands []JellyfinGeneralCommandType) SessionAPIPostCapabilitiesRequest {
	r.supportedCommands = &supportedCommands
	return r
}

// Determines whether media can be played remotely..
func (r SessionAPIPostCapabilitiesRequest) SupportsMediaControl(supportsMediaControl bool) SessionAPIPostCapabilitiesRequest {
	r.supportsMediaControl = &supportsMediaControl
	return r
}

// Determines whether the device supports a unique identifier.
func (r SessionAPIPostCapabilitiesRequest) SupportsPersistentIdentifier(supportsPersistentIdentifier bool) SessionAPIPostCapabilitiesRequest {
	r.supportsPersistentIdentifier = &supportsPersistentIdentifier
	return r
}

func (r SessionAPIPostCapabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCapabilitiesExecute(r)
}

/*
PostCapabilities Updates capabilities for a device.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIPostCapabilitiesRequest
*/
func (a *SessionAPIService) PostCapabilities(ctx context.Context) SessionAPIPostCapabilitiesRequest {
	return SessionAPIPostCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) PostCapabilitiesExecute(r SessionAPIPostCapabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.PostCapabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.playableMediaTypes != nil {
		t := *r.playableMediaTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "playableMediaTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "playableMediaTypes", t, "form", "multi")
		}
	}
	if r.supportedCommands != nil {
		t := *r.supportedCommands
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supportedCommands", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supportedCommands", t, "form", "multi")
		}
	}
	if r.supportsMediaControl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supportsMediaControl", r.supportsMediaControl, "form", "")
	} else {
		var defaultValue bool = false
		r.supportsMediaControl = &defaultValue
	}
	if r.supportsPersistentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supportsPersistentIdentifier", r.supportsPersistentIdentifier, "form", "")
	} else {
		var defaultValue bool = true
		r.supportsPersistentIdentifier = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIPostFullCapabilitiesRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	jellyfinClientCapabilitiesDto *JellyfinClientCapabilitiesDto
	id *string
}

// The MediaBrowser.Model.Session.ClientCapabilities.
func (r SessionAPIPostFullCapabilitiesRequest) JellyfinClientCapabilitiesDto(jellyfinClientCapabilitiesDto JellyfinClientCapabilitiesDto) SessionAPIPostFullCapabilitiesRequest {
	r.jellyfinClientCapabilitiesDto = &jellyfinClientCapabilitiesDto
	return r
}

// The session id.
func (r SessionAPIPostFullCapabilitiesRequest) Id(id string) SessionAPIPostFullCapabilitiesRequest {
	r.id = &id
	return r
}

func (r SessionAPIPostFullCapabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostFullCapabilitiesExecute(r)
}

/*
PostFullCapabilities Updates capabilities for a device.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIPostFullCapabilitiesRequest
*/
func (a *SessionAPIService) PostFullCapabilities(ctx context.Context) SessionAPIPostFullCapabilitiesRequest {
	return SessionAPIPostFullCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) PostFullCapabilitiesExecute(r SessionAPIPostFullCapabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.PostFullCapabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities/Full"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinClientCapabilitiesDto == nil {
		return nil, reportError("jellyfinClientCapabilitiesDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinClientCapabilitiesDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIRemoveUserFromSessionRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	userId string
}

func (r SessionAPIRemoveUserFromSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveUserFromSessionExecute(r)
}

/*
RemoveUserFromSession Removes an additional user from a session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param userId The user id.
 @return SessionAPIRemoveUserFromSessionRequest
*/
func (a *SessionAPIService) RemoveUserFromSession(ctx context.Context, sessionId string, userId string) SessionAPIRemoveUserFromSessionRequest {
	return SessionAPIRemoveUserFromSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionAPIService) RemoveUserFromSessionExecute(r SessionAPIRemoveUserFromSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.RemoveUserFromSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/User/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIReportSessionEndedRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
}

func (r SessionAPIReportSessionEndedRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReportSessionEndedExecute(r)
}

/*
ReportSessionEnded Reports that a session has ended.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIReportSessionEndedRequest
*/
func (a *SessionAPIService) ReportSessionEnded(ctx context.Context) SessionAPIReportSessionEndedRequest {
	return SessionAPIReportSessionEndedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) ReportSessionEndedExecute(r SessionAPIReportSessionEndedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.ReportSessionEnded")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPIReportViewingRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	itemId *string
	sessionId *string
}

// The item id.
func (r SessionAPIReportViewingRequest) ItemId(itemId string) SessionAPIReportViewingRequest {
	r.itemId = &itemId
	return r
}

// The session id.
func (r SessionAPIReportViewingRequest) SessionId(sessionId string) SessionAPIReportViewingRequest {
	r.sessionId = &sessionId
	return r
}

func (r SessionAPIReportViewingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReportViewingExecute(r)
}

/*
ReportViewing Reports that a session is viewing an item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SessionAPIReportViewingRequest
*/
func (a *SessionAPIService) ReportViewing(ctx context.Context) SessionAPIReportViewingRequest {
	return SessionAPIReportViewingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) ReportViewingExecute(r SessionAPIReportViewingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.ReportViewing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Viewing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemId == nil {
		return nil, reportError("itemId is required and must be specified")
	}

	if r.sessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionId", r.sessionId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "itemId", r.itemId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPISendFullGeneralCommandRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	jellyfinGeneralCommand *JellyfinGeneralCommand
}

// The MediaBrowser.Model.Session.GeneralCommand.
func (r SessionAPISendFullGeneralCommandRequest) JellyfinGeneralCommand(jellyfinGeneralCommand JellyfinGeneralCommand) SessionAPISendFullGeneralCommandRequest {
	r.jellyfinGeneralCommand = &jellyfinGeneralCommand
	return r
}

func (r SessionAPISendFullGeneralCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendFullGeneralCommandExecute(r)
}

/*
SendFullGeneralCommand Issues a full general command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @return SessionAPISendFullGeneralCommandRequest
*/
func (a *SessionAPIService) SendFullGeneralCommand(ctx context.Context, sessionId string) SessionAPISendFullGeneralCommandRequest {
	return SessionAPISendFullGeneralCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendFullGeneralCommandExecute(r SessionAPISendFullGeneralCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendFullGeneralCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Command"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinGeneralCommand == nil {
		return nil, reportError("jellyfinGeneralCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinGeneralCommand
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPISendGeneralCommandRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	command JellyfinGeneralCommandType
}

func (r SessionAPISendGeneralCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendGeneralCommandExecute(r)
}

/*
SendGeneralCommand Issues a general command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param command The command to send.
 @return SessionAPISendGeneralCommandRequest
*/
func (a *SessionAPIService) SendGeneralCommand(ctx context.Context, sessionId string, command JellyfinGeneralCommandType) SessionAPISendGeneralCommandRequest {
	return SessionAPISendGeneralCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		command: command,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendGeneralCommandExecute(r SessionAPISendGeneralCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendGeneralCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Command/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPISendMessageCommandRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	jellyfinMessageCommand *JellyfinMessageCommand
}

// The MediaBrowser.Model.Session.MessageCommand object containing Header, Message Text, and TimeoutMs.
func (r SessionAPISendMessageCommandRequest) JellyfinMessageCommand(jellyfinMessageCommand JellyfinMessageCommand) SessionAPISendMessageCommandRequest {
	r.jellyfinMessageCommand = &jellyfinMessageCommand
	return r
}

func (r SessionAPISendMessageCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendMessageCommandExecute(r)
}

/*
SendMessageCommand Issues a command to a client to display a message to the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @return SessionAPISendMessageCommandRequest
*/
func (a *SessionAPIService) SendMessageCommand(ctx context.Context, sessionId string) SessionAPISendMessageCommandRequest {
	return SessionAPISendMessageCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendMessageCommandExecute(r SessionAPISendMessageCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendMessageCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Message"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jellyfinMessageCommand == nil {
		return nil, reportError("jellyfinMessageCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jellyfinMessageCommand
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPISendPlaystateCommandRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	command JellyfinPlaystateCommand
	seekPositionTicks *int64
	controllingUserId *string
}

// The optional position ticks.
func (r SessionAPISendPlaystateCommandRequest) SeekPositionTicks(seekPositionTicks int64) SessionAPISendPlaystateCommandRequest {
	r.seekPositionTicks = &seekPositionTicks
	return r
}

// The optional controlling user id.
func (r SessionAPISendPlaystateCommandRequest) ControllingUserId(controllingUserId string) SessionAPISendPlaystateCommandRequest {
	r.controllingUserId = &controllingUserId
	return r
}

func (r SessionAPISendPlaystateCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendPlaystateCommandExecute(r)
}

/*
SendPlaystateCommand Issues a playstate command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param command The MediaBrowser.Model.Session.PlaystateCommand.
 @return SessionAPISendPlaystateCommandRequest
*/
func (a *SessionAPIService) SendPlaystateCommand(ctx context.Context, sessionId string, command JellyfinPlaystateCommand) SessionAPISendPlaystateCommandRequest {
	return SessionAPISendPlaystateCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		command: command,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendPlaystateCommandExecute(r SessionAPISendPlaystateCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendPlaystateCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Playing/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.seekPositionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seekPositionTicks", r.seekPositionTicks, "form", "")
	}
	if r.controllingUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controllingUserId", r.controllingUserId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SessionAPISendSystemCommandRequest struct {
	ctx context.Context
	ApiService *SessionAPIService
	sessionId string
	command JellyfinGeneralCommandType
}

func (r SessionAPISendSystemCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendSystemCommandExecute(r)
}

/*
SendSystemCommand Issues a system command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param command The command to send.
 @return SessionAPISendSystemCommandRequest
*/
func (a *SessionAPIService) SendSystemCommand(ctx context.Context, sessionId string, command JellyfinGeneralCommandType) SessionAPISendSystemCommandRequest {
	return SessionAPISendSystemCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		command: command,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendSystemCommandExecute(r SessionAPISendSystemCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendSystemCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/System/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jellyfin

import (
	"encoding/json"
	"fmt"
)

// JellyfinTranscodeReason the model 'JellyfinTranscodeReason'
type JellyfinTranscodeReason string

// List of TranscodeReason
const (
	CONTAINER_NOT_SUPPORTED JellyfinTranscodeReason = "ContainerNotSupported"
	VIDEO_CODEC_NOT_SUPPORTED JellyfinTranscodeReason = "VideoCodecNotSupported"
	AUDIO_CODEC_NOT_SUPPORTED JellyfinTranscodeReason = "AudioCodecNotSupported"
	SUBTITLE_CODEC_NOT_SUPPORTED JellyfinTranscodeReason = "SubtitleCodecNotSupported"
	AUDIO_IS_EXTERNAL JellyfinTranscodeReason = "AudioIsExternal"
	SECONDARY_AUDIO_NOT_SUPPORTED JellyfinTranscodeReason = "SecondaryAudioNotSupported"
	VIDEO_PROFILE_NOT_SUPPORTED JellyfinTranscodeReason = "VideoProfileNotSupported"
	VIDEO_LEVEL_NOT_SUPPORTED JellyfinTranscodeReason = "VideoLevelNotSupported"
	VIDEO_RESOLUTION_NOT_SUPPORTED JellyfinTranscodeReason = "VideoResolutionNotSupported"
	VIDEO_BIT_DEPTH_NOT_SUPPORTED JellyfinTranscodeReason = "VideoBitDepthNotSupported"
	VIDEO_FRAMERATE_NOT_SUPPORTED JellyfinTranscodeReason = "VideoFramerateNotSupported"
	REF_FRAMES_NOT_SUPPORTED JellyfinTranscodeReason = "RefFramesNotSupported"
	ANAMORPHIC_VIDEO_NOT_SUPPORTED JellyfinTranscodeReason = "AnamorphicVideoNotSupported"
	INTERLACED_VIDEO_NOT_SUPPORTED JellyfinTranscodeReason = "InterlacedVideoNotSupported"
	AUDIO_CHANNELS_NOT_SUPPORTED JellyfinTranscodeReason = "AudioChannelsNotSupported"
	AUDIO_PROFILE_NOT_SUPPORTED JellyfinTranscodeReason = "AudioProfileNotSupported"
	AUDIO_SAMPLE_RATE_NOT_SUPPORTED JellyfinTranscodeReason = "AudioSampleRateNotSupported"
	AUDIO_BIT_DEPTH_NOT_SUPPORTED JellyfinTranscodeReason = "AudioBitDepthNotSupported"
	CONTAINER_BITRATE_EXCEEDS_LIMIT JellyfinTranscodeReason = "ContainerBitrateExceedsLimit"
	VIDEO_BITRATE_NOT_SUPPORTED JellyfinTranscodeReason = "VideoBitrateNotSupported"
	AUDIO_BITRATE_NOT_SUPPORTED JellyfinTranscodeReason = "AudioBitrateNotSupported"
	UNKNOWN_VIDEO_STREAM_INFO JellyfinTranscodeReason = "UnknownVideoStreamInfo"
	UNKNOWN_AUDIO_STREAM_INFO JellyfinTranscodeReason = "UnknownAudioStreamInfo"
	DIRECT_PLAY_ERROR JellyfinTranscodeReason = "DirectPlayError"
	VIDEO_RANGE_TYPE_NOT_SUPPORTED JellyfinTranscodeReason = "VideoRangeTypeNotSupported"
	VIDEO_CODEC_TAG_NOT_SUPPORTED JellyfinTranscodeReason = "VideoCodecTagNotSupported"
)

// All allowed values of JellyfinTranscodeReason enum
var AllowedJellyfinTranscodeReasonEnumValues = []JellyfinTranscodeReason{
	"ContainerNotSupported",
	"VideoCodecNotSupported",
	"AudioCodecNotSupported",
	"SubtitleCodecNotSupported",
	"AudioIsExternal",
	"SecondaryAudioNotSupported",
	"VideoProfileNotSupported",
	"VideoLevelNotSupported",
	"VideoResolutionNotSupported",
	"VideoBitDepthNotSupported",
	"VideoFramerateNotSupported",
	"RefFramesNotSupported",
	"AnamorphicVideoNotSupported",
	"InterlacedVideoNotSupported",
	"AudioChannelsNotSupported",
	"AudioProfileNotSupported",
	"AudioSampleRateNotSupported",
	"AudioBitDepthNotSupported",
	"ContainerBitrateExceedsLimit",
	"VideoBitrateNotSupported",
	"AudioBitrateNotSupported",
	"UnknownVideoStreamInfo",
	"UnknownAudioStreamInfo",
	"DirectPlayError",
	"VideoRangeTypeNotSupported",
	"VideoCodecTagNotSupported",
}

func (v *JellyfinTranscodeReason) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := JellyfinTranscodeReason(value)
	for _, existing := range AllowedJellyfinTranscodeReasonEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid JellyfinTranscodeReason", value)
}

// NewJellyfinTranscodeReasonFromValue returns a pointer to a valid JellyfinTranscodeReason
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewJellyfinTranscodeReasonFromValue(v string) (*JellyfinTranscodeReason, error) {
	ev := JellyfinTranscodeReason(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for JellyfinTranscodeReason: valid values are %v", v, AllowedJellyfinTranscodeReasonEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v JellyfinTranscodeReason) IsValid() bool {
	for _, existing := range AllowedJellyfinTranscodeReasonEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to TranscodeReason value
func (v JellyfinTranscodeReason) Ptr() *JellyfinTranscodeReason {
	return &v
}

type NullableJellyfinTranscodeReason struct {
	value *JellyfinTranscodeReason
	isSet bool
}

func (v NullableJellyfinTranscodeReason) Get() *JellyfinTranscodeReason {
	return v.value
}

func (v *NullableJellyfinTranscodeReason) Set(val *JellyfinTranscodeReason) {
	v.value = val
	v.isSet = true
}

func (v NullableJellyfinTranscodeReason) IsSet() bool {
	return v.isSet
}

func (v *NullableJellyfinTranscodeReason) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableJellyfinTranscodeReason(val *JellyfinTranscodeReason) *NullableJellyfinTranscodeReason {
	return &NullableJellyfinTranscodeReason{value: val, isSet: true}
}

func (v NullableJellyfinTranscodeReason) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableJellyfinTranscodeReason) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


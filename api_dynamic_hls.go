/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package jellyfin

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// DynamicHlsAPIService DynamicHlsAPI service
type DynamicHlsAPIService service

type DynamicHlsAPIGetHlsAudioSegmentRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	playlistId string
	segmentId int32
	container string
	runtimeTicks *int64
	actualSegmentLengthTicks *int64
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
}

// The position of the requested segment in ticks.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) RuntimeTicks(runtimeTicks int64) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.runtimeTicks = &runtimeTicks
	return r
}

// The length of the requested segment in ticks.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) ActualSegmentLengthTicks(actualSegmentLengthTicks int64) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.actualSegmentLengthTicks = &actualSegmentLengthTicks
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Static(static bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Params(params string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Tag(tag string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MinSegments(minSegments int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) DeviceId(deviceId string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MaxStreamingBitrate(maxStreamingBitrate int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Profile(profile string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Level(level string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Framerate(framerate float32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Width(width int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Height(height int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetHlsAudioSegmentRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetHlsAudioSegmentRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r DynamicHlsAPIGetHlsAudioSegmentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetHlsAudioSegmentExecute(r)
}

/*
GetHlsAudioSegment Gets a video stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @param playlistId The playlist id.
 @param segmentId The segment id.
 @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
 @return DynamicHlsAPIGetHlsAudioSegmentRequest
*/
func (a *DynamicHlsAPIService) GetHlsAudioSegment(ctx context.Context, itemId string, playlistId string, segmentId int32, container string) DynamicHlsAPIGetHlsAudioSegmentRequest {
	return DynamicHlsAPIGetHlsAudioSegmentRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		playlistId: playlistId,
		segmentId: segmentId,
		container: container,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetHlsAudioSegmentExecute(r DynamicHlsAPIGetHlsAudioSegmentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetHlsAudioSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playlistId"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentId"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.runtimeTicks == nil {
		return localVarReturnValue, nil, reportError("runtimeTicks is required and must be specified")
	}
	if r.actualSegmentLengthTicks == nil {
		return localVarReturnValue, nil, reportError("actualSegmentLengthTicks is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "runtimeTicks", r.runtimeTicks, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "actualSegmentLengthTicks", r.actualSegmentLengthTicks, "form", "")
	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIGetHlsVideoSegmentRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	playlistId string
	segmentId int32
	container string
	runtimeTicks *int64
	actualSegmentLengthTicks *int64
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The position of the requested segment in ticks.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) RuntimeTicks(runtimeTicks int64) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.runtimeTicks = &runtimeTicks
	return r
}

// The length of the requested segment in ticks.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) ActualSegmentLengthTicks(actualSegmentLengthTicks int64) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.actualSegmentLengthTicks = &actualSegmentLengthTicks
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Static(static bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Params(params string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Tag(tag string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The desired segment length.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MinSegments(minSegments int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) DeviceId(deviceId string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Profile(profile string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Level(level string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Framerate(framerate float32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Width(width int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Height(height int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxWidth(maxWidth int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxHeight(maxHeight int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r DynamicHlsAPIGetHlsVideoSegmentRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) DynamicHlsAPIGetHlsVideoSegmentRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r DynamicHlsAPIGetHlsVideoSegmentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetHlsVideoSegmentExecute(r)
}

/*
GetHlsVideoSegment Gets a video stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @param playlistId The playlist id.
 @param segmentId The segment id.
 @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
 @return DynamicHlsAPIGetHlsVideoSegmentRequest
*/
func (a *DynamicHlsAPIService) GetHlsVideoSegment(ctx context.Context, itemId string, playlistId string, segmentId int32, container string) DynamicHlsAPIGetHlsVideoSegmentRequest {
	return DynamicHlsAPIGetHlsVideoSegmentRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		playlistId: playlistId,
		segmentId: segmentId,
		container: container,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetHlsVideoSegmentExecute(r DynamicHlsAPIGetHlsVideoSegmentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetHlsVideoSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playlistId"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentId"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.runtimeTicks == nil {
		return localVarReturnValue, nil, reportError("runtimeTicks is required and must be specified")
	}
	if r.actualSegmentLengthTicks == nil {
		return localVarReturnValue, nil, reportError("actualSegmentLengthTicks is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "runtimeTicks", r.runtimeTicks, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "actualSegmentLengthTicks", r.actualSegmentLengthTicks, "form", "")
	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"video/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIGetLiveHlsStreamRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	container *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	maxWidth *int32
	maxHeight *int32
	enableSubtitlesInManifest *bool
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The audio container.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Container(container string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.container = &container
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Static(static bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Params(params string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Tag(tag string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetLiveHlsStreamRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MinSegments(minSegments int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) DeviceId(deviceId string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Profile(profile string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Level(level string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Framerate(framerate float32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Width(width int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Height(height int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. The max width.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxWidth(maxWidth int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The max height.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) MaxHeight(maxHeight int32) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Whether to enable subtitles in the manifest.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) EnableSubtitlesInManifest(enableSubtitlesInManifest bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.enableSubtitlesInManifest = &enableSubtitlesInManifest
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r DynamicHlsAPIGetLiveHlsStreamRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) DynamicHlsAPIGetLiveHlsStreamRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r DynamicHlsAPIGetLiveHlsStreamRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLiveHlsStreamExecute(r)
}

/*
GetLiveHlsStream Gets a hls live stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIGetLiveHlsStreamRequest
*/
func (a *DynamicHlsAPIService) GetLiveHlsStream(ctx context.Context, itemId string) DynamicHlsAPIGetLiveHlsStreamRequest {
	return DynamicHlsAPIGetLiveHlsStreamRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetLiveHlsStreamExecute(r DynamicHlsAPIGetLiveHlsStreamRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetLiveHlsStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/live.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.container != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "container", r.container, "form", "")
	}
	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.enableSubtitlesInManifest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableSubtitlesInManifest", r.enableSubtitlesInManifest, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIGetMasterHlsAudioPlaylistRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableAudioVbrEncoding *bool
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Static(static bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Params(params string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Tag(tag string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MinSegments(minSegments int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) DeviceId(deviceId string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MaxStreamingBitrate(maxStreamingBitrate int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Profile(profile string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Level(level string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Framerate(framerate float32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Width(width int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Height(height int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMasterHlsAudioPlaylistExecute(r)
}

/*
GetMasterHlsAudioPlaylist Gets an audio hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIGetMasterHlsAudioPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetMasterHlsAudioPlaylist(ctx context.Context, itemId string) DynamicHlsAPIGetMasterHlsAudioPlaylistRequest {
	return DynamicHlsAPIGetMasterHlsAudioPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetMasterHlsAudioPlaylistExecute(r DynamicHlsAPIGetMasterHlsAudioPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetMasterHlsAudioPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIGetMasterHlsVideoPlaylistRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableTrickplay *bool
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Static(static bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Params(params string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Tag(tag string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MinSegments(minSegments int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) DeviceId(deviceId string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Profile(profile string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Level(level string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Framerate(framerate float32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Width(width int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Height(height int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxWidth(maxWidth int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxHeight(maxHeight int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Enable trickplay image playlists being added to master playlist.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) EnableTrickplay(enableTrickplay bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.enableTrickplay = &enableTrickplay
	return r
}

// Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMasterHlsVideoPlaylistExecute(r)
}

/*
GetMasterHlsVideoPlaylist Gets a video hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIGetMasterHlsVideoPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetMasterHlsVideoPlaylist(ctx context.Context, itemId string) DynamicHlsAPIGetMasterHlsVideoPlaylistRequest {
	return DynamicHlsAPIGetMasterHlsVideoPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetMasterHlsVideoPlaylistExecute(r DynamicHlsAPIGetMasterHlsVideoPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetMasterHlsVideoPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableTrickplay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTrickplay", r.enableTrickplay, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTrickplay = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIGetVariantHlsAudioPlaylistRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Static(static bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Params(params string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Tag(tag string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MinSegments(minSegments int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) DeviceId(deviceId string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MaxStreamingBitrate(maxStreamingBitrate int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Profile(profile string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Level(level string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Framerate(framerate float32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Width(width int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Height(height int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetVariantHlsAudioPlaylistExecute(r)
}

/*
GetVariantHlsAudioPlaylist Gets an audio stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIGetVariantHlsAudioPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetVariantHlsAudioPlaylist(ctx context.Context, itemId string) DynamicHlsAPIGetVariantHlsAudioPlaylistRequest {
	return DynamicHlsAPIGetVariantHlsAudioPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetVariantHlsAudioPlaylistExecute(r DynamicHlsAPIGetVariantHlsAudioPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetVariantHlsAudioPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/main.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIGetVariantHlsVideoPlaylistRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Static(static bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Params(params string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Tag(tag string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) PlaySessionId(playSessionId string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) SegmentLength(segmentLength int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MinSegments(minSegments int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) DeviceId(deviceId string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AudioCodec(audioCodec string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AudioChannels(audioChannels int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Profile(profile string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Level(level string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Framerate(framerate float32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Width(width int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Height(height int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxWidth(maxWidth int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxHeight(maxHeight int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) RequireAvc(requireAvc bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) DeInterlace(deInterlace bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) VideoCodec(videoCodec string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetVariantHlsVideoPlaylistExecute(r)
}

/*
GetVariantHlsVideoPlaylist Gets a video stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIGetVariantHlsVideoPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetVariantHlsVideoPlaylist(ctx context.Context, itemId string) DynamicHlsAPIGetVariantHlsVideoPlaylistRequest {
	return DynamicHlsAPIGetVariantHlsVideoPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetVariantHlsVideoPlaylistExecute(r DynamicHlsAPIGetVariantHlsVideoPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetVariantHlsVideoPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/main.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableAudioVbrEncoding *bool
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Static(static bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Params(params string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Tag(tag string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) PlaySessionId(playSessionId string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) SegmentLength(segmentLength int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MinSegments(minSegments int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) DeviceId(deviceId string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AudioCodec(audioCodec string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MaxStreamingBitrate(maxStreamingBitrate int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AudioChannels(audioChannels int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Profile(profile string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Level(level string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Framerate(framerate float32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Width(width int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Height(height int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) RequireAvc(requireAvc bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) DeInterlace(deInterlace bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) VideoCodec(videoCodec string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMasterHlsAudioPlaylistExecute(r)
}

/*
HeadMasterHlsAudioPlaylist Gets an audio hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest
*/
func (a *DynamicHlsAPIService) HeadMasterHlsAudioPlaylist(ctx context.Context, itemId string) DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest {
	return DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) HeadMasterHlsAudioPlaylistExecute(r DynamicHlsAPIHeadMasterHlsAudioPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.HeadMasterHlsAudioPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest struct {
	ctx context.Context
	ApiService *DynamicHlsAPIService
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *JellyfinSubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *JellyfinEncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableTrickplay *bool
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The media version id, if playing an alternate version.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MediaSourceId(mediaSourceId string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Static(static bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Params(params string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Tag(tag string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) DeviceProfileId(deviceProfileId string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) PlaySessionId(playSessionId string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) SegmentContainer(segmentContainer string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) SegmentLength(segmentLength int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MinSegments(minSegments int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) DeviceId(deviceId string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AudioCodec(audioCodec string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AudioSampleRate(audioSampleRate int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AudioBitRate(audioBitRate int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AudioChannels(audioChannels int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Profile(profile string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Level(level string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Framerate(framerate float32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxFramerate(maxFramerate float32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) CopyTimestamps(copyTimestamps bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) StartTimeTicks(startTimeTicks int64) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Width(width int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Height(height int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxWidth(maxWidth int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxHeight(maxHeight int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) VideoBitRate(videoBitRate int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) SubtitleMethod(subtitleMethod JellyfinSubtitleDeliveryMethod) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxRefFrames(maxRefFrames int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) RequireAvc(requireAvc bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) DeInterlace(deInterlace bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) LiveStreamId(liveStreamId string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) VideoCodec(videoCodec string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) SubtitleCodec(subtitleCodec string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) TranscodeReasons(transcodeReasons string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Context(context JellyfinEncodingContext) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) StreamOptions(streamOptions map[string]string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Enable trickplay image playlists being added to master playlist.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) EnableTrickplay(enableTrickplay bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.enableTrickplay = &enableTrickplay
	return r
}

// Whether to enable Audio Encoding.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMasterHlsVideoPlaylistExecute(r)
}

/*
HeadMasterHlsVideoPlaylist Gets a video hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest
*/
func (a *DynamicHlsAPIService) HeadMasterHlsVideoPlaylist(ctx context.Context, itemId string) DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest {
	return DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) HeadMasterHlsVideoPlaylistExecute(r DynamicHlsAPIHeadMasterHlsVideoPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.HeadMasterHlsVideoPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableTrickplay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTrickplay", r.enableTrickplay, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTrickplay = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
